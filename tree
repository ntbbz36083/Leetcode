96. Unique Binary Search Trees
https://leetcode.com/problems/unique-binary-search-trees/
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        cache = {}
        
        def counttree(n, cache):
            if n == 0:
                return 1     
            if n in cache:
                return cache[n]
            res = 0
            for i in range(n):
                left = counttree(i,cache)
                right = counttree(n-i-1,cache)
                res += left * right
            cache[n] = res    
            return res
        return counttree(n,cache)

95. Unique Binary Search Trees II
https://leetcode.com/problems/unique-binary-search-trees-ii/

class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        def buildtree(nums):
            if not nums:
                return [None]
            res = []
            for i in range(len(nums)):
                left_list = buildtree(nums[:i])
                right_list = buildtree(nums[i+1:])
                for left in left_list:
                    for right in right_list:
                        node = TreeNode(nums[i])
                        node.left = left
                        node.right = right
                        res+=[node]
            return res
        if n == 0:
            return []
        return buildtree([_ for _ in range(1,n+1)])


98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/

class Solution(object):
    def isValidBST(self, root, floor=float('-inf'), ceiling=float('inf')):
        if not root: 
            return True
        if root.val <= floor or root.val >= ceiling:
            return False
        # in the left branch, root is the new ceiling; contrarily root is the new floor in right branch
        return self.isValidBST(root.left, floor, root.val) and self.isValidBST(root.right, root.val, ceiling)

99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/
class Solution(object):
    def recoverTree(self, root): # O(n+lg(n)) space  
        res = []
        self.dfs(root, res)
        first, second = None, None
        for i in range(len(res)-1):
            if res[i].val > res[i+1].val and not first:
                first = res[i]
            if res[i].val > res[i+1].val and first:
                second = res[i+1]
        first.val, second.val = second.val, first.val
        
    def dfs(self, root, res):
        if root:
            self.dfs(root.left, res)
            res.append(root)
            self.dfs(root.right, res)

101. Symmetric Tree
https://leetcode.com/problems/symmetric-tree/

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.helper(root.left, root.right)
    def helper(self, node1, node2):
        if node1 and node2 and node1.val == node2.val:
            outer = self.helper(node1.left, node2.right)
            inner = self.helper(node1.right, node2.left)
            return outer and inner
        return node1 == node2

102. Binary Tree Level Order Traversal
#####  Iterative  ####
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp)
        return res

#####  Recurisve  ####
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res = []
        self.helper(root, 0, res)
        return res
    def helper(self, node, level, res):
        if not node:
            return
        if len(res) < level+1:
            res.append([])
        res[level].append(node.val)
        self.helper(node.left, level+1,res)
        self.helper(node.right, level+1,res)

103. Binary Tree Zigzag Level Order Traversal
https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

class Solution(object):
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        index = 1
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp[::index])
            index *= -1
        return res

104. Maximum Depth of Binary Tree
https://leetcode.com/problems/maximum-depth-of-binary-tree/
#####  Iterative  ####
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        i = 0
        q = collections.deque([root])
        while q:
            for j in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            i += 1
        return i
#####  Recursive  ####
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        return self.helper(root)
    def helper(self, node):
        if not node:
            return 0
        left = self.helper(node.left)
        right = self.helper(node.right)
        return max(left, right) + 1

105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if inorder:
            ind = inorder.index(preorder.pop(0))
            root = TreeNode(inorder[ind])
            root.left = self.buildTree(preorder,inorder[:ind])
            root.right = self.buildTree(preorder,inorder[ind+1:])
            return root

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        return self.build(preorder, 0,len(preorder)-1, inorder, 0, len(inorder)-1)
        
    def build(self, preorder, prestart, preend,
             inorder, instart, inend):
        if prestart>preend:
            return
        root_val = preorder[prestart]
        index = 0
        for i in range(instart,inend+1):
            if root_val == inorder[i]:
                index = i
                break
        left_len = index-instart
        root = TreeNode(root_val)
        root.left = self.build(preorder, prestart+1, prestart+left_len,inorder, instart, index-1)
        root.right = self.build(preorder, prestart+1+left_len, preend, inorder, index+1, inend)
        return root


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        return self.build(inorder, 0, len(inorder)-1, postorder, 0, len(postorder)-1)
    
    def build(self, inorder, instart, inend, postorder, poststart, postend):
        if instart > inend:
            return
        root_val = postorder[postend]
        index = -1
        for i in range(instart, inend+1):
            if inorder[i] == root_val:
                index = i
                break
        left_len = index - instart
        root = TreeNode(root_val)
        root.left = self.build(inorder, instart, index-1, postorder, poststart, poststart+left_len-1)
        root.right = self.build(inorder, index+1, inend, postorder, poststart+left_len, postend-1)
        return root

107. Binary Tree Level Order Traversal II
https://leetcode.com/problems/binary-tree-level-order-traversal-ii/

class Solution(object):
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp)
        return res[::-1]

108. Convert Sorted Array to Binary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
class Solution(object):
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        if not nums:
            return 
        return self.helper(nums,0,len(nums)-1)
    def helper(self, nums, left, right):
        if left > right:
            return
        mid = (left+right)/2
        root = TreeNode(nums[mid])
        root.left = self.helper(nums, left, mid-1)
        root.right = self.helper(nums, mid+1, right)
        return root

109. Convert Sorted List to Binary Search Tree
https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        if not head:
            return
        if not head.next:
            return TreeNode(head.val)
        pre, slow, fast = None, head, head
        while fast and fast.next:
            pre = slow
            slow = slow.next
            fast = fast.next.next
        pre.next = None
        
        root = TreeNode(slow.val)
        root.left = self.sortedListToBST(head)
        root.right = self.sortedListToBST(slow.next)
        return root
    

110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        return self.helper(root)!= -1

    def helper(self, node):
        if not node:
            return 0
        left = self.helper(node.left)
        if left == -1:
            return -1
        right = self.helper(node.right)
        if right == -1:
            return -1
        if abs(left-right)>1:
            return -1
        return max(left,right)+1
    
112. Path Sum
https://leetcode.com/problems/path-sum/
#####  Iterative  ####
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        q = collections.deque([(root,sum)])
        while q:
            node, val = q.popleft()
            if not node.left and not node.right and val == node.val:
                return True
            if node.left:
                q.append((node.left,val-node.val))
            if node.right:
                q.append((node.right, val-node.val))
        return False
            
#####  Recursive  ####
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        sum -= root.val
        if not root.left and not root.right and sum == 0:
            return True
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)

113. Path Sum II
https://leetcode.com/problems/path-sum-ii/
#####  Iterative  ####
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        if not root:
            return
        q, res = collections.deque([(root, sum, [])]), []
        while q:
            node,val,temp = q.popleft()
            if not node.left and not node.right and node.val == val:
                temp+=[node.val]
                res.append(temp)
            if node.left:
                q.append((node.left, val-node.val, temp+[node.val]))
            if node.right:
                q.append((node.right, val-node.val, temp+[node.val]))
        return res

#####  Recursive  ####
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res = []
        self.helper(root, sum, [], res)
        return res
    def helper(self, node, sum, ls, res):
        if node:
            if not node.left and not node.right and node.val == sum:
                ls.append(node.val)
                res.append(ls)
            self.helper(node.left, sum-node.val, ls+[node.val], res)
            self.helper(node.right, sum-node.val, ls+[node.val], res)

116. Populating Next Right Pointers in Each Node
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

class Solution(object):
#T:O(n)
#S:O(1)
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:
            return
        self.helper(root.left, root.right)
        return root
    def helper(self, node1, node2):
        if not node1 or not node2:
            return 
        node1.next = node2
        self.helper(node1.left,node1.right)
        self.helper(node2.left,node2.right)
        self.helper(node1.right,node2.left)

114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
class Solution(object):
#T:O(n)
#S:O(1)
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.left)
        self.flatten(root.right)
        left = root.left
        right = root.right
        root.left = None
        root.right = left
        p = root
        while p.right:
            p = p.right
        p.right = right
        return root

117. Populating Next Right Pointers in Each Node II
https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/
class Solution(object):
    def connect(self, root):
        q = collections.deque([root]) if root else []
        while q:
            m = len(q)
            while m:
                m -= 1
                node = q.popleft()
                if m != 0:
                    node.next = q[0]
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        return root
    

124. Binary Tree Maximum Path Sum
https://leetcode.com/problems/binary-tree-maximum-path-sum/
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_sum = float('-inf')
        self.dfs(root)
        return self.max_sum
    
    def dfs(self, node):
        if not node: return 0
        
        # only add positive contributions
        leftST_sum = max(0, self.dfs(node.left))
        rightST_sum = max(0, self.dfs(node.right))

        # check if cumulative sum at current node > global max sum so far
        # this evaluates a candidate path
        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)
        
        # add to the current node ONLY one of the children contributions
        # in order to maintain the constraint of considering only paths
        # if not, we would be exploring explore the whole tree - against problem definition
        return max(leftST_sum, rightST_sum) + node.val

129. Sum Root to Leaf Numbers
https://leetcode.com/problems/sum-root-to-leaf-numbers/
#####  Iterative  ####
class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return  0
        q = collections.deque([(root, 0)])
        res = 0
        while q:    
            node, ls = q.popleft()
            if not node.left and not node.right:
                ls = ls * 10 + node.val
                res += ls
            if node.left:
                q.append([node.left,ls*10+node.val])
            if node.right:
                q.append([node.right,ls*10+node.val])
        return res

#####  Recursive  ####
    def sumNumbers1(self, root): # DFS recursively 
            self.res = 0
            self.dfs(root, 0)
            return self.res

    def dfs(self, root, path):
        if root:
            if not root.left and not root.right:
                path = path*10 + root.val
                self.res += path
            self.dfs(root.left, path*10+root.val)
            self.dfs(root.right, path*10+root.val)

156. Binary Tree Upside Down
https://leetcode.com/problems/binary-tree-upside-down/
class Solution(object):
    def upsideDownBinaryTree(self, root):
        if not root:
            return root
        l = root.left
        r = root.right
        root.left = None
        root.right = None
        while l:
            new_l = l.left
            new_r = l.right
            l.left = r
            l.right = root
            root = l
            l = new_l
            r = new_r
        return root

173. Binary Search Tree Iterator
https://leetcode.com/problems/binary-search-tree-iterator/
class BSTIterator(object):

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left
        
    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        node = self.stack.pop()
        x = node.right
        while x:
            self.stack.append(x)
            x = x.left
        return node.val

    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return len(self.stack) > 0


199. Binary Tree Right Side View
https://leetcode.com/problems/binary-tree-right-side-view/
#####  Iterative  ####
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        q = collections.deque([(root,[])])
        res = []
        while q:
            for _ in range(len(q)):
                node, path = q.popleft()
                path += [node.val]
                if node.left:
                    q.append((node.left, path))
                if node.right:
                    q.append((node.right, path))
            res.append(path[-1])
        return res

#####  Recursive  ####        
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root, 0)
        return self.res
    def helper(self, node, level):
        if node:
            if level == len(self.res):
                self.res.append(node.val)
            self.helper(node.right, level+1)
            self.helper(node.left, level+1)

226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
class Solution(object):
#T:o(n)
#S:o(n)
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

class Solution(object):
#T:O(n)
#T:O(n)
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.rank = 0
        self.res = 0
        self.helper(root,k)
        return self.res
    def helper(self, root, k):
        if not root:
            return
        self.helper(root.left, k)
        self.rank += 1
        if self.rank == k:
            self.res = root.val
            return
        self.helper(root.right, k)

235. Lowest Common Ancestor of a Binary Search Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

class Solution(object):
#T:O(logn)
#S:O(logn)
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        while root:
            if max(p.val, q.val) < root.val:
                root = root.left
            elif min(p.val, q.val) > root.val:
                root = root.right
            else:
                return root
        return None
    

236. Lowest Common Ancestor of a Binary Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

class Solution(object):
#T:O(n)
#S:O(n)
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if root:
            if root==p or root==q:
                return root
            left = self.lowestCommonAncestor(root.left, p, q)
            right = self.lowestCommonAncestor(root.right, p, q)
            if left and right:
                return root
            if left or right:
                return left or right

255. Verify Preorder Sequence in Binary Search Tree
https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/
class Solution(object):
    i = 0
    def verifyPreorder(self, preorder):
        """
        :type preorder: List[int]
        :rtype: bool
        """
        st = []
        low = float('-inf')
        for x in preorder:
            if x < low:
                return False
            while st and st[-1] < x:
                low = st.pop()
            st.append(x)
        return True

1644. Lowest Common Ancestor of a Binary Tree II
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/
class Solution(object):
#T:O(n)
#S:O(n)
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        self.res = None
        self.helper(root, p, q)
        return self.res
    def helper(self, node, p,q):
        if node:
            left = self.helper(node.left, p,q)
            right = self.helper(node.right, p,q)
            # if both find, then current node is LCA
            if left and right:
                self.res = node
                return False
            # if either branch find and the other node exists, then current node is LCA
            elif (left or right) and (node == p or node == q):
                self.res = node
                return False
            #check whether p or q is in the tree
            elif node == p or node == q:
                return True
            # for everything else, return left or right if either finds something, otherwise false
            else:
                return left or right

250. Count Univalue Subtrees
https://leetcode.com/problems/count-univalue-subtrees/

lass Solution(object):
    def countUnivalSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.res = 0
        self.helper(root,0)
        return self.res
    def helper(self, node, parent):
        if node:
            left = self.helper(node.left, node.val)
            right = self.helper(node.right, node.val)
            if left and right:
                self.res += 1
            return left and right and node.val == parent
        return True

257. Binary Tree Paths
https://leetcode.com/problems/binary-tree-paths/
#####  Iterative  ####
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if not root:
            return []
        q = collections.deque([(root,[])])
        res = []
        while q:
            node, path = q.popleft()
            if not node.left and not node.right:
                path.append(node.val)
                res.append('->'.join([str(i) for i in path])) 
            if node.left:
                q.append((node.left, path+[node.val]))
            if node.right:
                q.append((node.right, path+[node.val]))
        return res
#####  Recursive  #### 
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if not root:
            return []
        self.res = []
        self.helper(root,[])
        return self.res
    def helper(self, node, path):
        if not node:
            return
        if not node.left and not node.right:
            path += [node.val]
            self.res.append('->'.join([str(i) for i in path]))
        self.helper(node.left, path + [node.val])
        self.helper(node.right, path + [node.val])

270. Closest Binary Search Tree Value
https://leetcode.com/problems/closest-binary-search-tree-value/
class Solution(object):
    def closestValue(self, root, target):
        """
        :type root: TreeNode
        :type target: float
        :rtype: int
        """
        self.res = 0
        self.min = float('inf')
        self.helper(root, target)
        return self.res
    
    def helper(self, node, target):
        if node:
            if abs(node.val - target) < self.min:
                self.min = abs(node.val - target) 
                self.res = node.val
            if target < node.val:
                self.helper(node.left, target)
            else:
                self.helper(node.right, target)

272. Closest Binary Search Tree Value II
https://leetcode.com/problems/closest-binary-search-tree-value-ii/
class Solution(object):
#T:O(k+logn)
#S:O(n)
    def closestKValues(self, root, target, k):
        """
        :type root: TreeNode
        :type target: float
        :type k: int
        :rtype: List[int]
        """
        res = []
        prestack = []
        succstack = []
        while root:
            if root.val < target:
                prestack.append(root)
                root = root.right
            else:
                succstack.append(root)
                root = root.left
        
        def getpre(stack):
            if stack:
                pre = stack.pop()
                p = pre.left
                while p:
                    stack.append(p)
                    p = p.right
                return pre
        def getsuc(stack):
            if stack:
                suc = stack.pop()
                p = suc.right
                while p:
                    stack.append(p)
                    p = p.left
                return suc
        pre = getpre(prestack)
        suc = getsuc(succstack)
        
        while k:
            k -= 1
            if pre and not suc:
                res.append(pre.val)
                pre = getpre(prestack)
            elif suc and not pre:
                res.append(suc.val)
                suc = getsuc(succstack)
            elif suc and pre and abs(pre.val - target) <= abs(suc.val-target):
                res.append(pre.val)
                pre = getpre(prestack)
            elif suc and pre and abs(pre.val - target) >= abs(suc.val-target):
                res.append(suc.val)
                suc = getsuc(succstack)
        return res

285. Inorder Successor in BST
https://leetcode.com/problems/inorder-successor-in-bst/

###### Recursive #######
class Solution(object):
    def inorderSuccessor(self, root, p):
        """
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        """
        if root:
            if root.val > p.val:
                return self.inorderSuccessor(root.left, p) or root 
            else:
                return self.inorderSuccessor(root.right,p)
                
###### Iterative #######                
class Solution(object):
    def inorderSuccessor(self, root, p):
        """
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        """
        succ = None
        while root:
            if root.val > p.val:
                succ = root
                root = root.left
            else:
                root = root.right
        return succ

297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
#################################  preorder traverse  #################################
#################################  preorder traverse  #################################
class Codec:

    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        self.traverse(root, res)
        #print(','.join(res))
        return ','.join(res)
    
    def traverse(self, root, res):
        if not root:
            res.append('#')
            return
        res.append(str(root.val))
        self.traverse(root.left, res)
        self.traverse(root.right, res)
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        nodes = data.split(',')
        return self.dtraverse(nodes)
    
    def dtraverse(self, nodes):
        if not nodes:
            return
        first = nodes.pop(0)
        if first == '#':
            return
        root = TreeNode(int(first))
        root.left = self.dtraverse(nodes)
        root.right = self.dtraverse(nodes)
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
#################################  level order traverse  #################################
#################################  level order traverse  #################################
class Codec:
#T:O(n)
#S:O(n)
    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        res = []
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if node:
                q.append(node.left)
                q.append(node.right)
            res.append(str(node.val) if node else "#")
        return ','.join(res)
    
    
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        nodes = data.split(',')
        root = TreeNode(int(nodes[0]))
        q = collections.deque([root])
        i = 1
        while q:
            node = q.popleft()
            if nodes[i] is not "#":
                node.left = TreeNode(int(nodes[i]))
                q.append(node.left)
            i += 1
            if nodes[i] is not "#":
                node.right = TreeNode(int(nodes[i]))
                q.append(node.right)
            i += 1
        return root
# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

298. Binary Tree Longest Consecutive Sequence
https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/

class Solution(object):
#T:O(n)
#S:O(n)
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.res = 0
        self.helper(root,0,root.val)
        return self.res
    def helper(self, node,cnt, target):
        if node:
            if node.val == target:
                cnt += 1
            else:
                target = node.val 
                cnt = 1
            self.res = max(self.res, cnt)
            self.helper(node.left, cnt, target+1)
            self.helper(node.right, cnt, target+1)

333. Largest BST Subtree
https://leetcode.com/problems/largest-bst-subtree/
class Solution(object):
    def largestBSTSubtree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if self.verifyBST(root, float('-inf'), float('inf')):
            return self.getcount(root)
        return max(self.largestBSTSubtree(root.left),self.largestBSTSubtree(root.right))
    
          
    def verifyBST(self, node, lo, hi):
        if not node:
            return True
        if node.val <= lo or node.val >= hi:
            return False
        left = self.verifyBST(node.left, lo, node.val)
        right = self.verifyBST(node.right, node.val, hi)
        return left and right
    
    def getcount(self, node):
        if not node:
            return 0
        left = self.getcount(node.left)
        right = self.getcount(node.right)
        return left+ right + 1

366. Find Leaves of Binary Tree
https://leetcode.com/problems/find-leaves-of-binary-tree/
class Solution(object):
    def findLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.dic =collections.defaultdict(list)
        self.helper(root)
        return list(self.dic.values())
        
    def helper(self, node):
        if node: 
            left = self.helper(node.left)
            right = self.helper(node.right)
            level = max(left, right) + 1
            self.dic[level].append(node.val)
            return level
        return 0

404. Sum of Left Leaves
https://leetcode.com/problems/sum-of-left-leaves/
class Solution(object):
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.res = 0
        self.helper(root)
        return self.res
        
    def helper(self, node):
        if node:
            if node.left and not node.left.left and not node.left.right:
                self.res += node.left.val
            self.helper(node.left)
            self.helper(node.right)

426. Convert Binary Search Tree to Sorted Doubly Linked List
https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/
class Solution(object):
    def treeToDoublyList(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:return
        dummy = Node(9,None,None)
        prev = dummy
        stack, node = [], root
        while stack or node:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            node.left, prev.right, prev = prev, node, node
            node = node.right
        dummy.right.left, prev.right = prev, dummy.right
        return dummy.right

428. Serialize and Deserialize N-ary Tree
https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/
class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        """
        res = []
        def dfs(node):
            if node:
                res.append(str(node.val))
                for child in node.children:
                    dfs(child)
                res.append('#')
        dfs(root)
        #print(res)
        return ','.join(res)
    
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        """
        if not data:
            return None
        data = collections.deque(data.split(','))
        root = Node(int(data.popleft()),[])
        q = [root]
        while data:
            val = data.popleft()
            if val == '#':
                
                q.pop()
            else:
                new = Node(int(val),[])
                q[-1].children.append(new)
                q.append(new)
        return root

429. N-ary Tree Level Order Traversal
https://leetcode.com/problems/n-ary-tree-level-order-traversal/
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: Node
        :rtype: List[List[int]]
        """
        if not root:
            return root
        q = collections.deque([(root,0)])
        res = []
        while q:
            node, level = q.popleft()
            if len(res) < level + 1:
                res.append([])
            for child in node.children:
                q.append((child,level+1))
            res[level].append(node.val)
        return res

437. Path Sum III
https://leetcode.com/problems/path-sum-iii/
https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-)
class Solution(object):
#T:O(nlogn) to O(n^2)
#S:O(n)
############### brute force  ###############
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """
        self.numpath = 0
        self.dfs(root, sum)
        return self.numpath
    
    def dfs(self, node, sum):
        if node:
            self.test(node, sum)
            self.dfs(node.left, sum)
            self.dfs(node.right, sum)
    def test(self, node, sum):
        if node:
            if node.val == sum:
                self.numpath += 1
            self.test(node.left, sum - node.val)
            self.test(node.right, sum - node.val)

############### memo  ###############
class Solution(object):
#T:O(n)
#S:O(n)
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """
        self.res = 0
        dic = {0:1}
        self.helper(root, sum, 0, dic)
        return self.res
    
    def helper(self, node, sum, curentpathsum, dic):
        if node:
            curentpathsum += node.val
            oldpathsum = curentpathsum - sum
            self.res += dic.get(oldpathsum,0)
            dic[curentpathsum] = dic.get(curentpathsum,0)+1
            
            self.helper(node.left, sum, curentpathsum, dic)
            self.helper(node.right, sum, curentpathsum, dic)
            dic[curentpathsum] -= 1
            
450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/

class Solution(object):
#T:O(n)
#S:O(1)
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root:
            return 
        if root.val == key:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            min_node = self.getmin(root.right)
            root.val = min_node.val
            root.right = self.deleteNode(root.right, min_node.val)
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            root.left = self.deleteNode(root.left, key)
        return root
    def getmin(self, node):
        while node.left:
            node = node.left
        return node

501. Find Mode in Binary Search Tree
https://leetcode.com/problems/find-mode-in-binary-search-tree/
#T:O(n)
#S:O(n)
class Solution(object):
    def findMode(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        self.dic={}
        self.helper(root)
        m = float('-inf')
        for key in self.dic:
            if self.dic[key]>m:
                m = self.dic[key]
        res = []
        for key,val in self.dic.items():
            if val == m:
                res.append(key)
        return res
    def helper(self, node):
        if node:
            self.dic[node.val] = self.dic.get(node.val,0)+1
            self.helper(node.left)
            self.helper(node.right)
class Solution(object):
#T:O(n)
#S:O(1)
    def findMode(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        self.prev = None
        self.curr_count = 0
        self.max_count = 0
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            self.helper(node.left)
            if node.val == self.prev:
                self.curr_count += 1
            else:
                self.curr_count = 1
            if self.curr_count > self.max_count:
                self.max_count = self.curr_count
                self.res = [node.val]
            elif self.curr_count == self.max_count:
                self.res.append(node.val)
            self.prev = node.val
            self.helper(node.right)

508. Most Frequent Subtree Sum
https://leetcode.com/problems/most-frequent-subtree-sum/
class Solution(object):
    def findFrequentTreeSum(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root is None: return []

        self.count = collections.Counter()
        self.dfs(root)
        maxCount = max(self.count.values())
        return [s for s in self.count if self.count[s] == maxCount]
    def dfs(self, node):
            if node is None: return 0
            s = node.val + self.dfs(node.left) + self.dfs(node.right)
            self.count[s] += 1
            return s

510. Inorder Successor in BST II
https://leetcode.com/problems/inorder-successor-in-bst-ii/
class Solution(object):
    def inorderSuccessor(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if node.right:
            right = node.right
            while right.left:
                right = right.left
            return right
        while node.parent:
            if node.parent.left == node:
                return node.parent
            node = node.parent
        return None

513. Find Bottom Left Tree Value
https://leetcode.com/problems/find-bottom-left-tree-value/
class Solution(object):
    def findBottomLeftValue(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        q = collections.deque([(root,1)])
        max_depth = 0
        ans = 0
        while q:
            node, level = q.popleft()
            if node:
                if level > max_depth:
                    max_depth = level
                    ans = node.val
                q.append((node.left, level+1))
                q.append((node.right, level+1))
        return ans

515. Find Largest Value in Each Tree Row
https://leetcode.com/problems/find-largest-value-in-each-tree-row/
class Solution(object):
    def largestValues(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft() 
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(max(temp))
        return res


530. Minimum Absolute Difference in BST
https://leetcode.com/problems/minimum-absolute-difference-in-bst/
class Solution(object):
    def getMinimumDifference(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.min = self.pre = float('inf')
        self.helper(root)
        return self.min
    
    def helper(self, node):
        if node:
            self.helper(node.left)
            self.min = min(self.min, abs(node.val-self.pre))
            self.pre = node.val
            self.helper(node.right)
            
536. Construct Binary Tree from String
https://leetcode.com/problems/construct-binary-tree-from-string/

class Solution(object):
    def str2tree(self, s):
        """
        :type s: str
        :rtype: TreeNode
        """
        if not s or len(s) ==0:
            return None
        node, i = self.helper(s, 0)
        return node
        
    def helper(self, s, i):
        start = i
        while i < len(s) and (s[i] == '-' or s[i].isdigit()):
            i += 1
        node = TreeNode(int(s[start:i]))
        if i < len(s) and s[i] == '(':
            i += 1
            node.left, i = self.helper(s,i)
            i += 1
        if i < len(s) and s[i] == '(':
            i += 1
            node.right, i = self.helper(s,i)
            i += 1
        return node, i

538. Convert BST to Greater Tree
https://leetcode.com/problems/convert-bst-to-greater-tree/

class Solution(object):
#T:O(n)
#S:O(1)
    def convertBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.sum = 0
        self.helper(root)
        return root
    def helper(self, root):
        if not root:
            return
        self.helper(root.right)
        self.sum += root.val
        root.val = self.sum
        self.helper(root.left)

543. Diameter of Binary Tree
https://leetcode.com/problems/diameter-of-binary-tree/
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.ans = 0
        self.helper(root)
        return self.ans
    
    def helper(self, node):
        if node:
            left, right = self.helper(node.left),self.helper(node.right)
            self.ans = max(self.ans, left+right)
            return max(left, right)+1
        return 0

545. Boundary of Binary Tree
https://leetcode.com/problems/boundary-of-binary-tree/
class Solution(object):
#T:O(n)
#S:O(n)
    def boundaryOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """

        def leftmost(node):
            if not node or not node.left and not node.right:
                return
            res.append(node.val)
            if node.left:
                leftmost(node.left)
            else:
                leftmost(node.right)
        def leaf(node):
            if not node:
                return
            leaf(node.left)
            if node != root and not node.left and not node.right:
                res.append(node.val)
            leaf(node.right)
        def rightmost(node):
            if not node or not node.left and not node.right:
                return 
            if node.right:
                rightmost(node.right)
            else:
                rightmost(node.left)
            res.append(node.val)
        if not root:
            return []
        res = [root.val]
        leftmost(root.left)
        leaf(root)
        rightmost(root.right)
        return res

559. Maximum Depth of N-ary Tree
https://leetcode.com/problems/maximum-depth-of-n-ary-tree/
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: Node
        :rtype: int
        """
        if not root:
            return 0
        height = 0
        for child in root.children:
            height = max(height, self.maxDepth(child))
        return height+1        

563. Binary Tree Tilt
https://leetcode.com/problems/binary-tree-tilt/
class Solution(object):
    def findTilt(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        self.helper(root)
        return self.res
        
    def helper(self, node):
        if node:
            left = self.helper(node.left)
            right = self.helper(node.right)
            self.res += abs(left - right)
            return node.val + left + right
        return 0


572. Subtree of Another Tree
https://leetcode.com/problems/subtree-of-another-tree/
class Solution(object):
    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s:
            return False
        if self.helper(s,t):
            return True
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
        
        
    def helper(self, p, q):
        if p and q:
            return p.val == q.val and self.helper(p.left, q.left) and self.helper(p.right, q.right)
        return p is q

582. Kill Process
https://leetcode.com/problems/kill-process/
############  Iterative  ############  
class Solution(object):
    def killProcess(self, pid, ppid, kill):
        """
        :type pid: List[int]
        :type ppid: List[int]
        :type kill: int
        :rtype: List[int]
        """
        parent, q = collections.defaultdict(list), collections.deque([kill])
        for kid, par in zip(pid, ppid):
            parent[par].append(kid)
        res = []        
        while q:
            for _ in range(len(q)):
                x = q.popleft()
                res.append(x)
                if x in parent:
                    q.extend(parent[x])
        return res
     
589. N-ary Tree Preorder Traversal
https://leetcode.com/problems/n-ary-tree-preorder-traversal/
class Solution(object):
    def preorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            self.res.append(node.val)
            for child in node.children:
                self.helper(child)
        
590. N-ary Tree Postorder Traversal
https://leetcode.com/problems/n-ary-tree-postorder-traversal/
class Solution(object):
    def postorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            for child in node.children:
                self.helper(child)
            self.res.append(node.val)
            

606. Construct String from Binary Tree
https://leetcode.com/problems/add-one-row-to-tree/

class Solution(object):
    def tree2str(self, t):
        """
        :type t: TreeNode
        :rtype: str
        """
        if not t:
            return ""
        res = ""
        left = self.tree2str(t.left)
        right = self.tree2str(t.right)
        if left or right:
            res += "(%s)" %left
        if right:
            res += "(%s)" %right
        return str(t.val)+res 
        
617. Merge Two Binary Trees
https://leetcode.com/problems/merge-two-binary-trees/
############  Recursive  ############
class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if t1 and t2:
            root = TreeNode(t1.val+t2.val)
            root.left = self.mergeTrees(t1.left, t2.left)
            root.right = self.mergeTrees(t1.right, t2.right)
            return root
        else:
            return t1 or t2
            
############  Iterative  ############  
class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if not t1 or not t2:
            return t1 or t2
        q1, q2 = collections.deque([t1]),collections.deque([t2])
        while q1 and q2:
            node1, node2 = q1.popleft(), q2.popleft()
            if node1 and node2:
                node1.val = node1.val + node2.val
                if (not node1.left) and node2.left:
                    node1.left = TreeNode(0)
                if (not node1.right) and node2.right:
                    node1.right = TreeNode(0)
                q1.append(node1.left)
                q1.append(node1.right)
                q2.append(node2.left)
                q2.append(node2.right)
        return t1
        
623. Add One Row to Tree
https://leetcode.com/problems/add-one-row-to-tree/
class Solution(object):
    def addOneRow(self, root, v, d):
        """
        :type root: TreeNode
        :type v: int
        :type d: int
        :rtype: TreeNode
        """
        if not root:
            return
        if d == 1:
            new_root = TreeNode(v)
            new_root.left = root
            return new_root
        q = collections.deque([root])
        i = 1
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                if i == d-1:
                    o_l = node.left
                    o_r = node.right
                    node.left = TreeNode(v)
                    node.right = TreeNode(v)
                    node.left.left = o_l
                    node.right.right = o_r
            i += 1
        return root


637. Average of Levels in Binary Tree
https://leetcode.com/problems/average-of-levels-in-binary-tree/
class Solution(object):
    def averageOfLevels(self, root):
        """
        :type root: TreeNode
        :rtype: List[float]
        """
        if not root:
            return []
        res = []
        q = collections.deque([root])
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft()
                temp.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(sum(temp)/float(len(temp)))
        return res

652. Find Duplicate Subtrees
https://leetcode.com/problems/find-duplicate-subtrees/
class Solution(object):
#T:O(n)
#S:O(n)
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        self.dic = {}
        self.res = []
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return '#'
        left = self.helper(root.left)
        right = self.helper(root.right)
        subtree = left + ','+right+','+ str(root.val)
        freq = self.dic.get(subtree,0)
        if freq == 1:
            self.res.append(root)
        self.dic[subtree] = self.dic.get(subtree,0) + 1
        return subtree



654. Maximum Binary Tree
https://leetcode.com/problems/maximum-binary-tree/
class Solution(object):
#T:O(nlogn)
#T:O(n)
    def constructMaximumBinaryTree(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        return self.build(nums,0,len(nums)-1)
        
    def build(self, nums, lo, hi):
        if lo > hi:
            return None
        index = -1
        max_val = float('-inf')
        for i in range(lo, hi+1):
            if nums[i] > max_val:
                index = i
                max_val = nums[i]
        new_root = TreeNode(max_val)
        new_root.left = self.build(nums, lo, index-1)
        new_root.right = self.build(nums, index+1, hi)
        return new_root

655. Print Binary Tree
https://leetcode.com/problems/print-binary-tree/
class Solution(object):
    def printTree(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[str]]
        """
        if not root:
            return
        height = self.getheight(root)
        width = 2 ** height - 1
        self.matrix = [["" for _ in range(width)] for _ in range(height)]
        self.update(root, 0, 0, width-1)
        return self.matrix
        
    def getheight(self, node):
        if not node:
            return 0
        return 1 + max(self.getheight(node.left),self.getheight(node.right))
    def update(self, node, row, left, right):
        if not node:
            return
        mid = (left+right)/2
        self.matrix[row][mid] = str(node.val)
        self.update(node.left, row+1, left, mid-1)
        self.update(node.right, row+1, mid+1, right)

662. Maximum Width of Binary Tree
https://leetcode.com/problems/maximum-width-of-binary-tree/

class Solution(object):
    def widthOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return
        q = collections.deque([(root, 0, 0)])
        cur_level = 0
        left = 0
        max_width = 0
        
        while q:
            for _ in range(len(q)):
                node, level, pos = q.popleft()
                if node:
                    q.append((node.left, level+1, pos*2))
                    q.append((node.right, level+1, pos*2+1))
                    if level != cur_level:
                        cur_level = level
                        left = pos
                    max_width = max(pos-left+1, max_width)
            
        return max_width

663. Equal Tree Partition
https://leetcode.com/problems/equal-tree-partition/
class Solution:
    def checkEqualTree(self, root: TreeNode) -> bool:
        self.root = root
        self.cuts = set()
        su = self.getsum(self.root)
        return su/2 in self.cuts
    def getsum(self, node: TreeNode)->int:
        if node:
            s = node.val + self.getsum(node.left) + self.getsum(node.right)
            if node is not self.root:
                self.cuts.add(s)
            return s
        return 0


666. Path Sum IV
https://leetcode.com/problems/path-sum-iv/
class Solution(object):
#T:O(n)
#S:O(n)
    def pathSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = collections.defaultdict(int)
        for num in nums:
            level, pos, val = num / 100, (num /10)%10, num%10
            dic[level, pos] = dic[level-1,(pos+1)/2] + val
        
        res = 0
        for level, pos in dic.keys():
            if (level+1, pos * 2) not in dic.keys() and (level+1, pos * 2-1) not in dic.keys():
                res += dic[level, pos]
        return res

669. Trim a Binary Search Tree
https://leetcode.com/problems/trim-a-binary-search-tree/
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        if not root:
            return
        if root.val > high:
            return self.trimBST(root.left, low, high)
        if root.val < low:
            return self.trimBST(root.right, low, high)
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        return root

671. Second Minimum Node In a Binary Tree
https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        self.second = float('inf')
        self.root = root
        self.helper(self.root)
        return self.second if self.second != float('inf') else -1
        
    def helper(self, node: TreeNode) -> int:
        if node:
            if self.root.val < node.val < self.second:
                self.second = node.val
            if self.root.val == node.val:
                self.helper(node.left)
                self.helper(node.right)

687. Longest Univalue Path
https://leetcode.com/problems/longest-univalue-path/
class Solution(object):
    def longestUnivaluePath(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.max= 0
        self.helper(root, None)
        return self.max
    
    def helper(self, node, parent):
        if node:
            left = self.helper(node.left, node.val)  
            right = self.helper(node.right, node.val)
            self.max = max(self.max, left+right)
            if node.val == parent:
                return max(left, right)+1
            else:
                return 0
        return 0

742. Closest Leaf in a Binary Tree
https://leetcode.com/problems/closest-leaf-in-a-binary-tree/
class Solution(object):
    def findClosestLeaf(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.dic = collections.defaultdict(list)
        self.s = set()
        self.traverse(root)
        q = collections.deque([k])
        seen = set()
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                if node in seen:
                    continue
                if node in self.s:
                    return node
                seen.add(node)
                q.extend(self.dic[node])
                
    def traverse(self, node):
        if not node:
            return
        if not node.left and not node.right:
            self.s.add(node.val)
            return
        if node.left:
            self.dic[node.val].append(node.left.val)
            self.dic[node.left.val].append(node.val)
            self.traverse(node.left)
        if node.right:
            self.dic[node.val].append(node.right.val)
            self.dic[node.right.val].append(node.val)
            self.traverse(node.right)

776. Split BST
https://leetcode.com/problems/split-bst/
class Solution(object):
    def splitBST(self, root, V):
        """
        :type root: TreeNode
        :type V: int
        :rtype: List[TreeNode]
        """
        if not root:
            return None, None
        if root.val > V:
            left, right = self.splitBST(root.left, V)
            root.left = right
            return [left, root]
        else:
            left, right = self.splitBST(root.right, V)
            root.right = left
            return [root, right]

814. Binary Tree Pruning
https://leetcode.com/problems/binary-tree-pruning/
class Solution(object):
    def pruneTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return None
        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        if not root.left and not root.right and not root.val:
            return None
        return root

863. All Nodes Distance K in Binary Tree
https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
class Solution(object):
#T:O(n)
#S:O(n)
    def distanceK(self, root, target, K):
        """
        :type root: TreeNode
        :type target: TreeNode
        :type K: int
        :rtype: List[int]
        """
        self.dic = collections.defaultdict(list)
        self.res = []
        self.visited = set()
        self.K = K
        self.dfs1(root)
        self.dfs2(target, 0)
        return self.res
    def dfs1(self, node):
        if node.left:
            self.dic[node.left].append(node)
            self.dic[node].append(node.left)
            self.dfs1(node.left)
        if node.right:
            self.dic[node.right].append(node)
            self.dic[node].append(node.right)
            self.dfs1(node.right)
    
    def dfs2(self, node, d):
        if d < self.K:
            self.visited.add(node)
            for v in self.dic[node]:
                if v not in self.visited:
                    self.dfs2(v, d+1)
        else:
            self.res.append(node.val)

865. Smallest Subtree with all the Deepest Nodes
https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
class Solution(object):
    def subtreeWithAllDeepest(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        return self.helper(root)[1]
    
    def helper(self, node):
        if node:
            hl, lca = self.helper(node.left)
            hr, rca = self.helper(node.right)
            if hl > hr:
                return hl+1, lca
            if hl < hr:
                return hr+1, rca
            return hl+1, node
        else:
            return 0, None

872. Leaf-Similar Trees
https://leetcode.com/problems/leaf-similar-trees/
class Solution(object):
    def leafSimilar(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: bool
        """
        arr1 = []
        arr2 = []
        self.helper(root1,arr1)
        self.helper(root2,arr2)

        return arr1 == arr2
    
    def helper(self, node, arr):
        if node:
            if not node.left and not node.right:
                arr.append(node.val)
            self.helper(node.left,arr)
            self.helper(node.right,arr)
    

889. Construct Binary Tree from Preorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
class Solution(object):
    preIndex, posIndex = 0, 0
        
    def constructFromPrePost(self, pre, post):
        root = TreeNode(pre[self.preIndex])
        self.preIndex += 1
        if (root.val != post[self.posIndex]):
            root.left = self.constructFromPrePost(pre, post)
        if (root.val != post[self.posIndex]):
            root.right = self.constructFromPrePost(pre, post)
        self.posIndex += 1
        return root
    
894. All Possible Full Binary Trees
https://leetcode.com/problems/all-possible-full-binary-trees/
class Solution(object):
    def allPossibleFBT(self, N):
        """
        :type N: int
        :rtype: List[TreeNode]
        """
        N -= 1
        if N == 0: return [TreeNode(0)]
        ret = []
        for l in range(1, N, 2):
            for left in self.allPossibleFBT(l):
                for right in self.allPossibleFBT(N - l):
                    root = TreeNode(0)
                    root.left = left
                    root.right = right
                    ret += [root]
        return ret

919. Complete Binary Tree Inserter
https://leetcode.com/problems/complete-binary-tree-inserter/
###### logic, level order traverse tree, add root'left and right to queue as long as root.right exist
###### if current node left exists, add right, pop out this node since it's completed and append new children
###### if left not exists, just append left
class CBTInserter:
#init O(n), insert O(1)
    def __init__(self, root: TreeNode):
        self.root = root
        self.q = deque([root])
        while self.q[0].right:
            parent = self.q.popleft()
            self.q.append(parent.left)
            self.q.append(parent.right)
    def insert(self, v: int) -> int:
        parent = self.q[0]
        if parent.left:
            parent.right = TreeNode(v)
            self.q.append(parent.left)
            self.q.append(parent.right)
            self.q.popleft()
        else:
            parent.left = TreeNode(v)
        return parent.val
    def get_root(self) -> TreeNode:
        return self.root

class CBTInserter:
#init O(1), insert O(n)
    def __init__(self, root: TreeNode):
        self.root = root
        self.q = deque([root])
        
    def insert(self, v: int) -> int:
        while self.q[0].right:
            parent = self.q.popleft()
            self.q.append(parent.left)
            self.q.append(parent.right)
        parent = self.q[0]
        if parent.left:
            parent.right = TreeNode(v)
            self.q.append(parent.left)
            self.q.append(parent.right)
            self.q.popleft()
        else:
            parent.left = TreeNode(v)
        return parent.val
    def get_root(self) -> TreeNode:
        return self.root
        
938. Range Sum of BST
https://leetcode.com/problems/range-sum-of-bst/
class Solution(object):
    def rangeSumBST(self, root, low, high):
        """
        :type root: TreeNode
        :type low: int
        :type high: int
        :rtype: int
        """
        if not root:
            return 0
        elif root.val < low:
            return self.rangeSumBST(root.right, low, high)
        elif root.val > high:
            return self.rangeSumBST(root.left, low, high)
        return root.val + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)

951. Flip Equivalent Binary Trees
https://leetcode.com/problems/flip-equivalent-binary-trees/
class Solution(object):
    def flipEquiv(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: bool
        """
        if not root1 or not root2:
            return root1 is root2         
        return root1.val == root2.val and (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) \
    or self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))

958. Check Completeness of a Binary Tree
https://leetcode.com/problems/check-completeness-of-a-binary-tree/
class Solution(object):
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        q = collections.deque([(root, 1)])
        res = []
        while q:
            u, coord = q.popleft()
            res.append(coord)
            if u.left:
                q.append((u.left, 2*coord))
            if u.right:
                q.append((u.right, 2*coord+1))
        return len(res) == res[-1]

965. Univalued Binary Tree
https://leetcode.com/problems/univalued-binary-tree/
class Solution(object):
    def isUnivalTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        self.x = root.val
        return self.helper(root)
    def helper(self, node):
        if node:
            if node.val != self.x:
                return False
            return self.helper(node.left) and self.helper(node.right)
        return True

968. Binary Tree Cameras
https://leetcode.com/problems/binary-tree-cameras/
class Solution(object):
    def minCameraCover(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.sum = 0
        if self.helper(root)==0:
            self.sum += 1
        return self.sum
    
    def helper(self, node):
        #0 means not cover, 1 means covered but no camera,
        #2 means camera on it
        if not node:
            return 1
        l = self.helper(node.left)
        r = self.helper(node.right)
        
        if l == 0 or r == 0:
            self.sum += 1
            return 2
        elif l == 2 or r == 2:
            return 1
        else:
            return 0
        
971. Flip Binary Tree To Match Preorder Traversal
https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        """
        :type root: TreeNode
        :type voyage: List[int]
        :rtype: List[int]
        """
        self.i, self.s = 0, []
        return self.s if self.helper(root, voyage) else [-1]
    def helper(self, node, voyage):
        if not node:
            return True
        if voyage[self.i] != node.val:
            return False
        self.i += 1
        if self.helper(node.left, voyage) and self.helper(node.right, voyage):
            return True
        if self.helper(node.right, voyage) and self.helper(node.left, voyage):
            self.s.append(node.val)
            return True
        return False
    

987. Vertical Order Traversal of a Binary Tree
https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/
class Solution(object):
#T:O(h*n)
#S:O(n)
    def verticalTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.dic = collections.defaultdict(list)
        q = collections.deque([(root,0)])
        self.min_l, self.max_l = 0,0
        while q:
            tmp = collections.defaultdict(list)
            for _ in range(len(q)):
                node, l = q.popleft()
                tmp[l].append(node.val)
                if node.left:
                    q.append((node.left,l-1))
                    self.min_l = min(self.min_l, l-1)
                if node.right:
                    q.append((node.right,l+1))
                    self.max_l = max(self.max_l, l+1)
            for i in tmp:
                self.dic[i] += sorted(tmp[i])
        return [self.dic[i] for i in range(self.min_l, self.max_l+1)]

988. Smallest String Starting From Leaf
https://leetcode.com/problems/smallest-string-starting-from-leaf/
class Solution(object):
    def smallestFromLeaf(self, root):
        """
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        self.res = [None]
        self.helper(root, '')
        return self.res[0]
    
    def helper(self, root, s):
        s = s + chr(ord('a') + root.val)
        if not root.left and not root.right:
            if self.res[0] == None:
                self.res[0] = s[::-1]
            else:
                self.res[0] = min(self.res[0], s[::-1])
        if root.left:
            self.helper(root.left, s)
        if root.right:
            self.helper(root.right, s)
        

993. Cousins in Binary Tree
https://leetcode.com/problems/cousins-in-binary-tree/
class Solution(object):
    def isCousins(self, root, x, y):
        """
        :type root: TreeNode
        :type x: int
        :type y: int
        :rtype: bool
        """
        q = collections.deque([(root, 0, 0)])
        dic = {}
        while q:
            node, level, parent = q.popleft()
            dic[node.val] = (level, parent)
            if node.left:
                q.append((node.left, level+1, node.val))
            if node.right:
                q.append((node.right, level+1, node.val))
        if dic[x][0] == dic[y][0] and dic[x][1] != dic[y][1]:
            return True
        return False

1008. Construct Binary Search Tree from Preorder Traversal
https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/
class Solution(object):
#T:O(n)
#S:O(h)
    def bstFromPreorder(self, preorder):
        """
        :type preorder: List[int]
        :rtype: TreeNode
        """
        self.i = 0
        return self.helper(preorder, float('inf'))
    
    def helper(self, A, bound = float('inf')):
        if self.i == len(A) or A[self.i] > bound:
            return None
        node = TreeNode(A[self.i])
        self.i += 1
        node.left = self.helper(A, node.val)
        node.right = self.helper(A, bound)
        return node

1022. Sum of Root To Leaf Binary Numbers
https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
class Solution(object):
    def sumRootToLeaf(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.dfs(root,0)
        
    def dfs(self, node, val):
        if not node:
            return 0
        val = val * 2 + node.val
        if not node.left and not node.right:
            return val
        return self.dfs(node.left, val)+self.dfs(node.right, val)
        

1026. Maximum Difference Between Node and Ancestor
https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/
class Solution(object):
    def maxAncestorDiff(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.m = float('-inf')
        self.helper(root, 0, 100000)
        return self.m
    
    def helper(self, node, mx,mn):
        if node:
            self.helper(node.left, max(mx,node.val), min(mn,node.val))
            self.helper(node.right, max(mx,node.val), min(mn,node.val))
        else:
            self.m = max(self.m,mx-mn)
            return

1104. Path In Zigzag Labelled Binary Tree
https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/
class Solution(object):
#T:O(logn)
#S:O(h)
    def pathInZigZagTree(self, label):
        """
        :type label: int
        :rtype: List[int]
        """
        level = 1
        res = []
        while label >= 2 ** level:
            level += 1
        while label > 0:
            res.append(label)
            cur_max, cur_min = 2**level -1, 2**(level-1)
            label = int(cur_max+cur_min-label)/2
            level -= 1
        return res[::-1]

1110. Delete Nodes And Return Forest
https://leetcode.com/problems/delete-nodes-and-return-forest/
class Solution(object):
    def delNodes(self, root, to_delete):
        """
        :type root: TreeNode
        :type to_delete: List[int]
        :rtype: List[TreeNode]
        """
        self.s = set(to_delete)
        self.res = []
        self.helper(root, False)
        return self.res
    
    def helper(self, node, parent):  
        if node is None:
            return None
        if node.val in self.s:
            node.left = self.helper(node.left, parent=False)
            node.right = self.helper(node.right, parent=False)
            return None
        else:
            if not parent:
                self.res.append(node)
            node.left = self.helper(node.left, parent=True)
            node.right = self.helper(node.right, parent=True)
            return node

1120. Maximum Average Subtree
https://leetcode.com/problems/maximum-average-subtree/
class Solution(object):
    def maximumAverageSubtree(self, root):
        """
        :type root: TreeNode
        :rtype: float
        """
        self.m = -float('inf')
        self.helper(root)
        return self.m
    
    def helper(self,node):
        if node:
            left, l_c = self.helper(node.left)
            right, r_c = self.helper(node.right)
            self.m = max(self.m, float((left+right+node.val))/float(l_c+r_c+1))
            return ((left+right+node.val), (l_c+r_c+1))
        else:
            return 0,0

1130. Minimum Cost Tree From Leaf Values
https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/
DP:
#T:O(n3)
#S:O(n2)
class Solution(object):
    def mctFromLeafValues(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        return self.dp(arr, 0, len(arr)-1, {})
    def dp(self, arr, l, r, cache):
        if (l, r) in cache:
            return cache[(l,r)]
        if l >= r:
            return 0
        res = float('inf')
        for i in range(l,r):
            val = max(arr[l:i+1]) * max(arr[i+1:r+1])
            res = min(res, val + self.dp(arr, l, i, cache) + self.dp(arr,i+1,r ,cache))
        cache[(l,r)] = res
        return res
#T:O(n2)
#S:O(n)
def mctFromLeafValues(self, A):
        res = 0
        while len(A) > 1:
            i = A.index(min(A))
            res += min(A[i - 1:i] + A[i + 1:i + 2]) * A.pop(i)
        return res

1145. Binary Tree Coloring Game
https://leetcode.com/problems/binary-tree-coloring-game/
class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        """
        :type root: TreeNode
        :type n: int
        :type x: int
        :rtype: bool
        """
        q = collections.deque([root])
        red_node = None
        r_l, r_r, p_o = 0,0,0
        while q:
            cur_node = q.popleft()
            if cur_node.val == x:
                red_node = cur_node
            else:
                p_o += 1
                if cur_node.left:
                    q.append(cur_node.left)
                if cur_node.right:
                    q.append(cur_node.right)
        if red_node.left:
            q.append(red_node.left)
            while q:
                cur_node = q.popleft()
                r_l += 1
                if cur_node.left:
                    q.append(cur_node.left)
                if cur_node.right:
                    q.append(cur_node.right)
        else:
            r_l = 0
        r_r = n-r_l-p_o-1
        low, med, high = sorted([r_l,r_r,p_o])
        return high > n/2

1161. Maximum Level Sum of a Binary Tree
https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
class Solution(object):
#T:O(n)
#T:O(h)
    def maxLevelSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        m, res = float('-inf'), 1
        q = collections.deque([(root,1)])
        while q:
            su = 0
            for _ in range(len(q)):
                node, level = q.popleft()
                su += node.val
                if node.left:
                    q.append((node.left, level+1))
                if node.right:
                    q.append((node.right, level+1))
            if m < su:
                m, res = su, level
        return res

1245. Tree Diameter
https://leetcode.com/problems/tree-diameter/
class Solution(object):
    def treeDiameter(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: int
        """
        self.graph = collections.defaultdict(list)
        for u,v in edges:
            self.graph[u].append(v)
            self.graph[v].append(u)
        node, level = self.dfs(0)
        return self.dfs(node)[1]
        
    def dfs(self, pos):
        max_level = float('-inf')
        visited = set()
        stack = [(pos,0)]
        while stack:
            node, level = stack.pop()
            if node in visited:
                continue
            visited.add(node)
            if max_level < level:
                max_level = level
                farestnode = node
            for nei in self.graph[node]:
                stack.append((nei, level + 1))
        return (farestnode, max_level)

1302. Deepest Leaves Sum
https://leetcode.com/problems/deepest-leaves-sum/
class Solution(object):
    def deepestLeavesSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.height = self.getheight(root)
        self.res = 0
        self.helper(root,1)
        return self.res
    
    def getheight(self, node):
        if node:
            left = self.getheight(node.left)
            right = self.getheight(node.right)
            return max(left,right)+1
        return 0
    
    def helper(self, node, h):
        if node:
            if h == self.height:
                self.res += node.val
            self.helper(node.left,h+1)
            self.helper(node.right,h+1)

1305. All Elements in Two Binary Search Trees
https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
class Solution(object):
#T:O(n1+n2)
#S:O(n1+n2)
    def getAllElements(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: List[int]
        """
        res = []
        l1,l2 = [], []
        self.helper(root1,l1)
        self.helper(root2, l2)
        i,j = 0,0
        while i<len(l1) and j < len(l2):
            if l1[i]> l2[j]:
                res.append(l2[j])
                j += 1
            else:
                res.append(l1[i])
                i += 1
        
        return res + l1[i:] + l2[j:]
    
    def helper(self, node, l):
        if node:
            self.helper(node.left, l)
            l.append(node.val)
            self.helper(node.right, l)
        

1315. Sum of Nodes with Even-Valued Grandparent
https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
class Solution(object):
    def sumEvenGrandparent(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        self.helper(root)
        return self.res
        
    def helper(self, node):
        if node:
            if node.val % 2 == 0:
                if node.left:
                    if node.left.left:
                        self.res += node.left.left.val
                    if node.left.right:
                        self.res += node.left.right.val
                if node.right:
                    if node.right.left:
                        self.res += node.right.left.val
                    if node.right.right:
                        self.res += node.right.right.val
            self.helper(node.left)
            self.helper(node.right)

1325. Delete Leaves With a Given Value
https://leetcode.com/problems/delete-leaves-with-a-given-value/
class Solution(object):
    def removeLeafNodes(self, root, target):
        """
        :type root: TreeNode
        :type target: int
        :rtype: TreeNode
        """
        if root.left:
            root.left = self.removeLeafNodes(root.left, target)
        if root.right:
            root.right = self.removeLeafNodes(root.right, target)
        if root.left == root.right and root.val == target:
            return None
        else:
            return root

1339. Maximum Product of Splitted Binary Tree
https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
class Solution(object):
    def maxProduct(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = []
        total = self.getSum(root)
        return max([(total-x) * x for x in self.res])% (10**9+7) 
            
        
    def getSum(self, node):
        if node:
            left = self.getSum(node.left)
            right = self.getSum(node.right)
            ans = left+right+node.val
            self.res.append(ans)
            return ans
        else:
            return 0

1367. Linked List in Binary Tree
https://leetcode.com/problems/linked-list-in-binary-tree/
class Solution(object):
    def isSubPath(self, head, root):
        """
        :type head: ListNode
        :type root: TreeNode
        :rtype: bool
        """
        if not head:
            return True
        if not root:
            return False
        return self.helper(head,root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right) 
        
    def helper(self, head, root):
        if not head:
            return True
        if not root:
            return False
        return head.val == root.val and (self.helper(head.next, root.left) or self.helper(head.next, root.right))

1372. Longest ZigZag Path in a Binary Tree
https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
class Solution:
    def longestZigZag(self, root: TreeNode) -> int:
        self.res = 0
        self.helper(root)
        return self.res-1
    def helper(self, node):
        if not node:
            return 0, 0
        _, lr = self.helper(node.left)
        rl, _ = self.helper(node.right)
        self.res = max(self.res, lr+1, rl+1)
        return lr+1, rl+1

1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/
class Solution(object):
    def getTargetCopy(self, original, cloned, target):
        """
        :type original: TreeNode
        :type cloned: TreeNode
        :type target: TreeNode
        :rtype: TreeNode
        """
        if not original or not cloned:
            return None
        stack = [(original, cloned)]
        while stack:
            org, clone = stack.pop()
            if org == target:
                return clone
            if org.left:
                stack.append((org.left, clone.left))
            if org.right:
                stack.append((org.right, clone.right))

1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
https://leetcode.com/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/
class Solution(object):
    def isValidSequence(self, root, arr):
        """
        :type root: TreeNode
        :type arr: List[int]
        :rtype: bool
        """
        return self.helper(0, root, arr)
        
    def helper(self, i, node, arr):
        if not node or i == len(arr) or arr[i] != node.val:
            return False
        if i == len(arr)-1 and not node.left and not node.right:
            return True
        return self.helper(i+1, node.left, arr) or self.helper(i+1, node.right, arr)

1443. Minimum Time to Collect All Apples in a Tree
https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/
class Solution(object):
    def minTime(self, n, edges, hasApple):
        """
        :type n: int
        :type edges: List[List[int]]
        :type hasApple: List[bool]
        :rtype: int
        """
        path = collections.defaultdict(list)
        for frm, to in edges:
            path[frm].append(to)
            path[to].append(frm)
        
        self.cost = 0
        seen = set()
        
        def dfs(current):
            found = False
            if current in seen:
                return
            seen.add(current)
            for nei in path[current]:
                if dfs(nei):
                    found = True
                    self.cost += 2
            return found or hasApple[current]
        dfs(0)
        return self.cost

1448. Count Good Nodes in Binary Tree
https://leetcode.com/problems/count-good-nodes-in-binary-tree/
class Solution(object):
#T:O(logn)
#T:O(h)
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        self.helper(root,root.val)
        return self.res
    
    def helper(self, node, m):
        if node:
            if node.val >= m:
                self.res += 1
                m = node.val
            self.helper(node.left, m)
            self.helper(node.right, m)

1457. Pseudo-Palindromic Paths in a Binary Tree
https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
class Solution(object):
    def pseudoPalindromicPaths (self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        self.helper(root, set())
        return self.res
    
    def helper(self, node, cur):
        if node:
            cur.remove(node.val) if node.val in cur else cur.add(node.val)
            if not node.left and not node.right:
                if len(cur) <= 1: self.res += 1
            else:
                self.helper(node.left, cur)
                self.helper(node.right, cur)
            cur.remove(node.val) if node.val in cur else cur.add(node.val)

1469. Find All The Lonely Nodes
https://leetcode.com/problems/find-all-the-lonely-nodes/
class Solution(object):
    def getLonelyNodes(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            if node.left and not node.right:
                self.res.append(node.left.val)
            if node.right and not node.left:
                self.res.append(node.right.val)
            self.helper(node.left)
            self.helper(node.right)

1485. Clone Binary Tree With Random Pointer
https://leetcode.com/problems/clone-binary-tree-with-random-pointer/
class Solution:
    def copyRandomBinaryTree(self, root: 'Node') -> 'NodeCopy':
        
        self.createNodeCopyNodes(root)
        self.populateRandom(root)
                    
        return self.breakNodes(root)

        
    def createNodeCopyNodes(self, root):
        if not root:
            return root
        
        newRoot = NodeCopy(root.val)
        
        newRoot.left = root.left
        newRoot.right = root.right
        
        root.left = newRoot
        root.right = None
        
        self.createNodeCopyNodes(newRoot.left)
        self.createNodeCopyNodes(newRoot.right)
        
    def populateRandom(self, root):
        if not root:
            return root
        
        newRoot = root.left
        if root.random:
            newRoot.random = root.random.left
        else:
            newRoot.random = None
            
        self.populateRandom(newRoot.left)
        self.populateRandom(newRoot.right)
        
    def breakNodes(self, root):
        if not root:
            return root
        newRoot = root.left
        root.left = newRoot.left
        root.right = newRoot.right
        if root.left:
            newRoot.left = self.breakNodes(root.left)
        if root.right:
            newRoot.right = self.breakNodes(root.right)
        return newRoot

1490. Clone N-ary Tree
https://leetcode.com/problems/clone-n-ary-tree/
class Solution(object):
    def cloneTree(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:
            return None
        newroot = Node(root.val)
        for child in root.children:
            newroot.children.append(self.cloneTree(child))
        return newroot

1530. Number of Good Leaf Nodes Pairs
https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/
class Solution(object):
    def countPairs(self, root, distance):
        """
        :type root: TreeNode
        :type distance: int
        :rtype: int
        """
        self.count = 0
        self.dfs(root, distance)
        return self.count
    
    def dfs(self, node, distance):
        if not node:
            return []
        if not node.left and not node.right:
            return [1]
        left = self.dfs(node.left, distance)
        right = self.dfs(node.right, distance)
        self.count += sum(l+r <= distance for l in left for r in right)
        return [n+1 for n in left + right if n+1<distance]
    
1586. Binary Search Tree Iterator II
https://leetcode.com/problems/binary-search-tree-iterator-ii/
#### with precalculation  ###
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.res = []
        self._iot(root)        
        self.n = len(self.res)
        self.i = -1
    def hasNext(self) -> bool:
        if self.i+1 < self.n:
            return True
        return False

    def next(self) -> int:
        self.i += 1
        return self.res[self.i]
    def hasPrev(self) -> bool:
        if self.i-1 >=0:
            return True
        return False

    def prev(self) -> int:
        self.i -= 1
        return self.res[self.i]
    
    def _iot(self, root):
        if not root:
            return None
        self._iot(root.left)
        self.res.append(root.val)
        self._iot(root.right)
    
#### without precalculation  ###
class BSTIterator:

    def __init__(self, root: TreeNode):
        dummy = TreeNode(val=float('-inf'), right=root)    
        self.stack=[dummy]
        # leftmost and rightmost is used for checking whether we are at the boundary
        self.leftmost = root
        while self.leftmost.left:
            self.leftmost = self.leftmost.left
            
        self.rightmost = root
        while self.rightmost.right:
            self.rightmost = self.rightmost.right
            
    def hasNext(self) -> bool:
        if self.stack[-1].val >= self.rightmost.val:
            return False
        return True
    
    def next(self) -> int:
        # get the last node of stack, if it has right subtree, find its leftmost leave, which will be the next, append all the parent through the way
         
        node = self.stack[-1]
        if node.right:
            node = node.right
            while node:
                self.stack.append(node)
                node = node.left
            return self.stack[-1].val
        # to understand here, we can use below example
        # for example, this happens on the rightmost node of left tree, to find the next node, we need to go back all the way to the root node
        node = self.stack.pop()
        while self.stack and self.stack[-1].left is not node:
            node = self.stack.pop()
        return self.stack[-1].val
    
    def hasPrev(self) -> bool:
        if self.stack[-1].val <= self.leftmost.val:
            return False
        return True
    
    def prev(self) -> int:
        node = self.stack[-1]
        if node.left:
            node = node.left
            while node:
                self.stack.append(node)
                node = node.right
            return self.stack[-1].val
        
        node = self.stack.pop()
        while self.stack and self.stack[-1].right is not node:
            node = self.stack.pop()
        return self.stack[-1].val
1602. Find Nearest Right Node in Binary Tree
https://leetcode.com/problems/find-nearest-right-node-in-binary-tree/
class Solution(object):
    def findNearestRightNode(self, root, u):
        """
        :type root: TreeNode
        :type u: TreeNode
        :rtype: TreeNode
        """
        q = collections.deque([root])
        while q:
            x = len(q)
            for i in range(x):
                node = q.popleft()
                if node == u:
                    if i == x-1:
                        return None
                    else:
                        return q[0]
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

1609. Even Odd Tree
https://leetcode.com/problems/even-odd-tree/
class Solution(object):
    def isEvenOddTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        q = collections.deque([root])
        is_even = True
        while q:
            prev = None
            for i in range(len(q)):
                node = q.popleft()
                if is_even:
                    if node.val % 2 == 0: return False
                    if prev and prev.val >= node.val: return False
                else:
                    if node.val % 2 == 1: return False
                    if prev and prev.val <= node.val: return False
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
                prev = node
            is_even = not is_even
        return True
                

1612. Check If Two Expression Trees are Equivalent
https://leetcode.com/problems/check-if-two-expression-trees-are-equivalent/
class Solution(object):
#T:O(n)
#T:O(26)
    def checkEquivalence(self, root1, root2):
        """
        :type root1: Node
        :type root2: Node
        :rtype: bool
        """
        self.d = collections.Counter()
        self.helper(root1,1)
        self.helper(root2,-1)
        return all(x == 0 for x in self.d.values())
    
    def helper(self, node, sign):
        if not node:
            return
        if node.val == '+':
            self.helper(node.left, sign)
            self.helper(node.right, sign)
        elif node.val == '-':
            self.helper(node.left, sign)
            self.helper(node.right, -sign)
        else:
            self.d[node.val] += sign
