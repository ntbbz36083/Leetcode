This post will include all 3 reverse words in a string question in leetcode, which are:
151. Reverse Words in a String
186. Reverse Words in a String II
557. Reverse Words in a String III

The general approach is

change string to a list. s = list(s) ind = len(s)
reverse whole list.
reverse each word in array.
To reverse, we create 2 function to reverse a whole list and reverse the each word in list.
def reverse_list(self, s, i, j):
        while i < j:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1 
T: O(n/2) S: O(1)
def reverse_word(self, s, ind):
        i = 0
        j = 0
        while i < ind:
			# This will skip any space that are in front of the word
            while i < j or (i < ind and s[i] == ' '):
                i += 1
			# This will find the position that word ends.
            while j < i or (j < ind and s[j] != ' '):
                j += 1
			# reverse list between i, j-1, which is the position of the word
            self.reverse(s, i, j-1)
T: O(nlogn) S: O(1)
By using above 2 functions, we can easily handle:
186. Reverse Words in a String II --- which string is already converted to a list, so no need for step1
557. Reverse Words in a String III --- which has no space and we can reverse it diretly.

Since there are spaces in string in 151. Reverse Words in a String, we can use another function to take care of the spaces.

    def remove_space(self, s, ind):
        i, j = 0, 0
        while j < ind:
			# skip all spaces before a word 
            while j < ind and s[j] == ' ':
                j += 1
			# put words in its right posistion
            while j < ind and s[j] != ' ':
                s[i] = s[j]
                i += 1
                j += 1
			# skip all spaces after a word
            while j < ind and s[j] == ' ':
                j += 1
			# if a word is done, we need to add a space at the end of it so we can keep the original format.
            if j < ind:
                s[i] = ' '
                i += 1
        return s[:i]
T: O(n) S: O(1)
So for 151. Reverse Words in a String: T: O(n+logn) S: O(1)

https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/361665/summary-python-detailed-explainition-with-3-follow-up
We have 2 solution to resolve this issue.

2 pointers
hashmap
If 2 arrays are not sorted, we would prefer dic method since it use less time with more space.
2 pointers: T->O(logmn + m + n) S->O(1)
dic: T->O(m + n) S->O(m)
follow-up1:What if the given array is already sorted? How would you optimize your algorithm?
If 2 arrays are sorted, we will use 2 pointers since it will use less storage.
follow-up2:What if nums1's size is small compared to nums2's size? Which algorithm is better?
We will use the smaller one to create the dic

follow-up3:What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/82243/Solution-to-3rd-follow-up-question
! If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.
! If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), read (let's say) 2G of each into memory and then using the 2 pointer technique, then read 2G more from the array that has been exhausted. Repeat this until no more data to read from disk.

### Two pointers Solution
class Solution(object):
    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        if not nums1 or not nums2:
            return 
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        n1 = len(nums1)
        n2 = len(nums2)
        l1, l2 = 0, 0
        res = []
        while l1 < n1 and l2 < n2:
            if nums1[l1] == nums2[l2]:
                res.append(nums1[l1])
                l1 += 1
                l2 += 1
            elif nums1[l1] < nums2[l2]:
                l1 += 1
            else:
                l2 += 1
        return res
### hashmap
class Solution(object):
    def intersect(self, nums1, nums2):

        counts = {}
        res = []

        for num in nums1:
            counts[num] = counts.get(num, 0) + 1

        for num in nums2:
            if num in counts and counts[num] > 0:
                res.append(num)
                counts[num] -= 1

        return res
https://leetcode.com/problems/add-binary/discuss/361542/detailed-python-explaintion

class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        # reverse a,b so we can caluculate
        a = a[::-1]
        b = b[::-1]
        res = []
        c = 0
        # find shorter one and start loop
        if len(b) > len(a):
            b, a = a, b
        # loop the shorter one first, append sum to the res, track c
        for i in range(len(b)):
            a_i = int(a[i])
            b_i = int(b[i])
            s = a_i + b_i + c
            c = s >= 2
            res.append(str(s % 2))
        # after shorter one is done, set i to the length of shorter oneï¼Œ
        # so we can start next loop
        i = len(b)
        # if c is True and i < len(a), start loop
        while c and i < len(a):
            s = int(a[i]) + c
            c = s >= 2
            res.append(str(s % 2))
            i += 1
        # if c not exists, we just need to append a[i:] to res
        # if c exists, after above execution, it will jump to the end 
        # of longer one, if c still exists, which means we need to add one
        # more digit to the res
        if i < len(a):
            res.append(a[i:])
        if c:
            res.append('1')
        # return as a string
        return ''.join(res)[::-1]
	
This is an explaination for
https://leetcode.com/problems/verifying-an-alien-dictionary/discuss/203185/JavaC%2B%2BPython-Mapping-to-Normal-Order
Thanks for this smart solution!
For example,
words = ["hello","leetcode"]
order = "hlabcdefgijkmnopqrstuvwxyz"

Create a dic, key is each word in new order, value is its index, which means its new position in the new order.
dic = {u'a': 2, u'c': 4, u'b': 3, u'e': 6, u'd': 5, u'g': 8, u'f': 7, u'i': 9, u'h': 0, u'k': 11, u'j': 10, u'm': 12, u'l': 1, u'o': 14, u'n': 13, u'q': 16, u'p': 15, u's': 18, u'r': 17, u'u': 20, u't': 19, u'w': 22, u'v': 21, u'y': 24, u'x': 23, u'z': 25}

Transform the list of words into its index in new order.
words = ["hello","leetcode"] -> [[0, 6, 1, 1, 14], [1, 6, 6, 19, 4, 14, 5, 6]]

zip
zip() will zip 2 element one by one,
zip(words, words[1:]) here will combine first element(words[0]) in words with
words[1], so we can compare current element with next element: 0->1, 1->2

For list comparision, if we want w1 < w2, if len(w1) = len(w2), it will compare each element in w1/w2, if everyone successes, return True.
If len is different. then if len(w1) > len(w2): it will return false since null is less than anything. if len(w1) < len(w2), then as long as everyone in w1 is less than its corresponding cmpoent in w2, it will return True.
This is the same as lexicographicaly sort.
if w1 > w2: since testcase is missing duplicates in the list, so to handle duplicate, we use > instead of >=

class Solution(object):
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        dic = {}
        new_words = []
        for i, ch in enumerate(order):
            dic[ch] = i
        for w in words:
            new = []
            for c in w:
                new.append(dic[c])
            new_words.append(new)
        for w1, w2 in zip(new_words, new_words[1:]):
            if w1 > w2:
                return False
        return True
