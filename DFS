
17. Letter Combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if not digits:
            return []
        d = {"2":"abc", "3":"def", "4":"ghi", "5":"jkl", "6":"mno", "7":"pqrs", "8":"tuv", "9":"wxyz"}
        res = []
        def dfs(index, path):
            if len(path)==len(digits):
                res.append(path)
            else:
                for c in d[digits[index]]:
                    dfs(index+1, path + c)        
        dfs(0, "")
        return res

46. Permutations
https://leetcode.com/problems/permutations/
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        visited = set()
        self.dfs(nums,visited, [], res)
        return res
    def dfs(self, nums, visited, path, res):
        if len(path) == len(nums):
            res.append(path)
        for i in range(len(nums)):
            if i not in visited:
                visited.add(i)
                self.dfs(nums, visited, path + [nums[i]], res)
                visited.remove(i)
                
51. N-Queens
https://leetcode.com/problems/n-queens/

class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        self.n = n
        res = []
        board = [["." for _ in range(n)] for _ in range(n)]
        self.backtrack(board, 0, res)
        return res
        
    def backtrack(self, board, row, res):
        if row == self.n:
            new = [''.join(x) for x in board]
            res.append(new)
            return
        for col in range(self.n):
            if self.isVaild(board, row, col):
                board[row][col] = 'Q'
                self.backtrack(board,row+1, res)
                board[row][col] = '.'

    def isVaild(self, board, row, col):
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        i,j=0,0
        for r, c in zip(range(row, -1, -1), range(col, -1, -1)):
            if board[r][c] == "Q":
                return False
        for r, c in zip(range(row, -1, -1), range(col, self.n)):
            if board[r][c] == "Q":
                return False
        return True
        
130. Surrounded Regions
#######  DFS  #######
https://leetcode.com/problems/surrounded-regions/
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return

        for i in [0, len(board)-1]:
            for j in range(len(board[0])):
                self.dfs(i,j,board)
        for i in range(len(board)):
            for j in [0, len(board[0])-1]:
                self.dfs(i,j,board)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == '.':
                    board[i][j] = 'O'
                    
    def dfs(self, i, j, board):
        if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == 'O':
            board[i][j] = '.'
            self.dfs(i+1,j, board)
            self.dfs(i-1,j, board)
            self.dfs(i,j+1, board)
            self.dfs(i,j-1, board)
            
#######  Union Find  #######
class UF(object):
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
            
    def connected(self, a, b):
        return self.find(a) == self.find(b)
        
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return
        m, n = len(board), len(board[0])
        uf = UF(m*n+1)
        
        for i in range(m):
            for j in [0,n-1]:
                if board[i][j] == 'O':
                    uf.union(i*n+j,m*n)
        for i in [0,m-1]:
            for j in range(n):
                if board[i][j] == 'O':
                    uf.union(i*n+j,m*n)
        
        d = [(1,0),(-1,0),(0,1), (0,-1)]
        for i in range(1,m-1):
            for j in range(1,n-1):
                if board[i][j] == 'O':
                    for dir in d:
                        x = i + dir[0]
                        y = j + dir[1]
                        if board[x][y] == 'O':
                            uf.union(i*n+j,x*n+y)
        for i in range(m):
            for j in range(n):
                if not uf.connected(i*n+j, m*n):
                    board[i][j] = 'X'

131. Palindrome Partitioning
https://leetcode.com/problems/palindrome-partitioning/
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        res = []
        self.dfs(s, [], res)
        return res
    
    def dfs(self, s, path, res):
        if not s:
            res.append(path)
            return
        for i in range(1,len(s)+1):
            if self.pal(s[:i]):
                self.dfs(s[i:], path + [s[:i]], res)
            
    def pal(self, s):
        return s == s[::-1]

200. Number of Islands
https://leetcode.com/problems/number-of-islands/
#######  DFS  #######
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        self.m, self.n = len(grid), len(grid[0])
        res = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == '1':
                    self.helper(grid, i, j)
                    res += 1
        return res    
    def helper(self, grid, i, j):
        if 0 <= i < self.m and 0 <= j < self.n and grid[i][j] == '1':
            grid[i][j] = '#'
            self.helper(grid,i+1, j)
            self.helper(grid,i-1, j)
            self.helper(grid,i, j+1)
            self.helper(grid,i, j-1)
            
#######  Union Find  #######
class UF(object):
    def __init__(self, m,n,grid):
        self.parent = [i for i in range(m*n)]
        self.rank = [0 for _ in range(m*n)]
        self.count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.count += 1
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
            
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
        self.count -= 1    
    def connected(self, a, b):
        return self.find(a) == self.find(b)
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if not grid:
            return 0        
        m, n = len(grid), len(grid[0])
        uf = UF(m,n,grid)
        d = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for dir in d:
                        x = i + dir[0]
                        y = j + dir[1]
                        if 0<= x < m and 0<= y < n and grid[x][y] == '1':
                            uf.union((i*n+j), (x*n+y))                            
        return uf.count    

207. Course Schedule
https://leetcode.com/problems/course-schedule/
class Solution:
#T:O(V+E), v is vetex number, E is egde number
#S:O(E)
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = collections.defaultdict(list)
        for p in prerequisites:
            x, y = p
            graph[x] += [y]
        visited = [0 for _ in range(numCourses)]
        for i in range(numCourses):
            if self.dfs(graph, visited, i):
                return False
        return True
    
    def dfs(self, graph, visited, i):
            if visited[i] == -1:
                return True
            if visited[i] == 1:
                return False
            visited[i] = -1
            for j in graph[i]:
                if self.dfs(graph, visited, j):
                    return False
            visited[i] = 1
            return False

210. Course Schedule II
https://leetcode.com/problems/course-schedule-ii/
class Solution:
#T:O(V+E), v is vetex number, E is egde number
#S:O(E)
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        visited = [0 for _ in range(numCourses)]
        res = []
        for p in prerequisites:
            x, y = p
            graph[x] += [y]
        for i in range(numCourses):
            if self.dfs(graph, visited, i, res):
                return []
        return res
    
    def dfs(self, graph, visited, i, res):
            if visited[i] == -1:
                return True
            if visited[i] == 1:
                return
            visited[i] = -1
            for j in graph[i]:
                if self.dfs(graph, visited, j, res):
                    return []
            res.append(i)
            visited[i] = 1

261. Graph Valid Tree
https://leetcode.com/problems/graph-valid-tree/
class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if n-1 != len(edges):
            return False
        d = collections.defaultdict(list)
        for a,b in edges:
            d[a].append(b)
            d[b].append(a)
        self.visited = set()
        if self.dfs(d, 0, -1):
            return False 
        return True if len(self.visited) == n else False
    
    def dfs(self, d, v, parent):
        self.visited.add(v)
        for nei in d[v]:
            if nei not in self.visited:
                if self.dfs(d, nei, v):
                    return False
            elif nei != parent:
                return True
        return False

323. Number of Connected Components in an Undirected Graph
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/
#######  DFS  ######
class Solution(object):
    def countComponents(self, n, edges):
#T:O(E+V)
#S:O(n)
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        g = collections.defaultdict(list) #space O(n)
        visited = set() #space O(n)
        res = 0
        for edge in edges: #time O(e) edge number 
            g[edge[0]].append(edge[1])
            g[edge[1]].append(edge[0])
        for i in range(n): #not all visited, only those vertex O(v), worest O(n), best o(1)
            if i not in visited:
                self.dfs(i,g,visited)
                res += 1
        return res
    
    def dfs(self, vertex, g, visited):
        if vertex not in visited:
            visited.add(vertex)
            for nei in g[vertex]:
                self.dfs(nei, g, visited)

#######  Union Find  ######
class Solution(object):
    def countComponents(self, n, edges):
#T:O(E+V)
#S:O(n)
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        def find(a):
            while a != parent[a]:
                parent[a] = parent[parent[a]]
                a = parent[a]
            return a
        
        def union(a,b):
            a, b = find(a), find(b)
            if a != b:
                if parent[a] < parent[b]:
                    parent[a] = b
                    rank[b] += 1
                else:
                    parent[b] = a
                    rank[a] += 1
                    #if rank[a] == rank[b]:
                        #rank[a] += 1
        parent, rank = [i for i in range(n)], [0 for _ in range(n)]
        for e in edges:
            union(e[0], e[1])
        
        return len([0 for i in range(n) if i == parent[i]])

339. Nested List Weight Sum
https://leetcode.com/problems/nested-list-weight-sum/
class Solution:
#T:O(n) n is the number of all elements
#S:O(d) d us the depth of nestedlist
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        return self.dfs(nestedList, 1)
        
    
    def dfs(self, nestedList, depth):
        res = 0
        for item in nestedList:
            if item.isInteger():
                res += item.getInteger() * depth
            else:
                res +=self.dfs(item.getList(), depth+1)
        return res
        
364. Nested List Weight Sum II
https://leetcode.com/problems/nested-list-weight-sum-ii/
class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
        max_depth = self.getDepth(nestedList)
        self.res = 0
        self.dfs(nestedList, 0, max_depth)
        return self.res
    
    def dfs(self, nestedList, level, max_depth):
         for item in nestedList:
            if item.isInteger():
                self.res += item.getInteger() * (max_depth-level)
            else:
                self.dfs(item.getList(), level+1, max_depth)
            
    def getDepth(self, nestedList):
        depth = 1
        for item in nestedList:
            if not item.isInteger():
                depth = max(depth, self.getDepth(item.getList())+1)
        return depth

394. Decode String
https://leetcode.com/problems/decode-string/


417. Pacific Atlantic Water Flow
https://leetcode.com/problems/pacific-atlantic-water-flow/
class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix:
            return []
        self.m, self.n = len(matrix), len(matrix[0])
        self.dire = [(1,0),(-1,0),(0,1),(0,-1)]
        p_visited = set()
        a_visited = set()
        
        for i in range(self.m):
            self.dfs(matrix,i,0,p_visited)
            self.dfs(matrix,i,self.n-1,a_visited)
        for j in range(self.n):
            self.dfs(matrix,0,j,p_visited)
            self.dfs(matrix,self.m-1,j,a_visited)
        
        return list(p_visited & a_visited)
        
    def dfs(self, matrix,i,j, visited):
        if (i,j) in visited:
            return
        visited.add((i,j))
        for d in self.dire:
            x,y = i+d[0], j+d[1]
            if 0 <= x < self.m and 0 <= y < self.n:
                if matrix[x][y] >= matrix[i][j]:
                    self.dfs(matrix,x,y,visited)

430. Flatten a Multilevel Doubly Linked List
https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/
"""
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
"""

class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        if not head:
            return head
        stack, order = [head], []
        while stack:
            last = stack.pop()
            order.append(last)
            if last.next:
                stack.append(last.next)
            if last.child:
                stack.append(last.child)
        for i in range(len(order)-1):
            order[i+1].prev = order[i]
            order[i].next = order[i+1]
            order[i].child = None
        return order[0]

473. Matchsticks to Square
https://leetcode.com/problems/matchsticks-to-square/
class Solution:
    def makesquare(self, nums: List[int]) -> bool:
        if len(nums) < 4:
            return False
        s = sum(nums)
        if s % 4:
            return False
        nums.sort(reverse=True)#logn
        target = s // 4
        if nums[0]> target:
            return False
        return self.dfs(0, [target]*4, nums)
        
    def dfs(self, pos, lefts, nums):
        if pos == len(nums):
            return True
        n = nums[pos]
        used = set()
        for i, left in enumerate(lefts):
            if n <= left and left not in used:
                lefts[i] -= n
                if self.dfs(pos+1, lefts, nums):
                    return True
                lefts[i] += n
                used.add(left)
        return False

494. Target Sum
https://leetcode.com/problems/target-sum/
class Solution:
#T:O(ns)
#S:O(ns)
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        d = collections.defaultdict(int)
        return self.dfs(0, S, d, nums)
        
    def dfs(self, index, s, d, nums):
        if (index, s) not in d:
            r = 0
            if index == len(nums):
                if s == 0:
                    r = 1
            else:
                r = self.dfs(index+1,s+nums[index], d, nums) + self.dfs(index+1,s-nums[index], d, nums)
            d[(index,s)] = r
        return d[(index,s)]

526. Beautiful Arrangement
https://leetcode.com/problems/beautiful-arrangement/
class Solution:
    def countArrangement(self, n: int) -> int:
        self.count = 0
        visited = [False for _ in range(n+1)]
        self.dfs(visited,n,1)
        return self.count
    
    def dfs(self, visited,n,pos):
        if pos>n:
            self.count += 1
            return
        for i in range(1,n+1):
            if not visited[i] and (i % pos==0  or pos% i == 0):
                visited[i] = True
                self.dfs(visited,n,pos+1)
                visited[i] = False
    
529. Minesweeper
https://leetcode.com/problems/minesweeper/
class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        if not board:
            return []
        i,j = click[0], click[1]
        if board[i][j] == 'M':
            board[i][j] = 'X'
            return board
        
        self.m, self.n = len(board), len(board[0])
        self.dfs(board,i,j)
        return board
    
    def dfs(self, board, i, j):
        if board[i][j] != 'E':
            return
        directions = [(-1,-1), (0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0)]
        mine_count = 0
        for d in directions:
            x, y = i+d[0], j+d[1]
            if 0 <= x < self.m and 0 <= y < self.n and board[x][y] =='M':
                mine_count += 1
        if mine_count == 0:
            board[i][j] = 'B'
        else:
            board[i][j] = str(mine_count)
            return
        for d in directions:
            x, y = i+d[0], j+d[1]
            if 0 <= x < self.m and 0 <= y < self.n:
                self.dfs(board,x,y)
                
542. 01 Matrix
https://leetcode.com/problems/01-matrix/
#################################  BFS for each 1  ######################################
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix:
            return[]
        self.m, self.n = len(matrix), len(matrix[0])
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 1:
                    self.bfs(i,j,matrix)
        return matrix
    
    def bfs(self, i, j, matrix):
        q = collections.deque([(i,j,0)])
        while q:
            I,J, step = q.popleft()
            for x, y in [(I+1,J),(I-1,J),(I,J+1),(I,J-1)]: 
                if 0 <= x < self.m and 0 <= y < self.n:
                    if matrix[x][y] == 0:
                        matrix[i][j] = step+1
                        return
                    else:
                        q.append((x,y,step+1))

#################################  BFS for each 0  ######################################
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix:
            return[]
        self.m, self.n = len(matrix), len(matrix[0])
        q = collections.deque()
        visited = set()
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 0:
                    q.append((i,j))
                    visited.add((i, j))
                    
        while q:
            x,y = q.popleft()
            for r, c in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if (r,c) in visited:
                    continue 
                else:
                    if 0 <= r < self.m and 0 <= c < self.n:
                        matrix[r][c] = matrix[x][y] + 1
                        q.append((r,c))
                        visited.add((r,c))
        return matrix

547. Friend Circles
https://leetcode.com/problems/friend-circles/

576. Out of Boundary Paths
https://leetcode.com/problems/out-of-boundary-paths/
class Solution:
    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:
        mod = 10**9+7
        cache = collections.defaultdict(int)
        def helper(i,j,N):
            if (i,j,N) in cache:
                return cache[(i,j,N)]
            if 0 <= i < m and 0 <= j < n:
                if N ==0:
                    cache[(i,j,N)]=0
                    return cache[(i,j,N)]
                for x,y in [(i+1,j),(i-1,j),(i,j+1), (i,j-1)]:
                    cache[(i,j,N)] += helper(x,y,N-1)
                return cache[(i,j,N)] % mod
            else:
                cache[(i,j,N)]=1
                return cache[(i,j,N)]
        return helper(i,j,N) % mod

638. Shopping Offers
https://leetcode.com/problems/shopping-offers/
class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        d = {}
        special = list(filter(lambda x:all(x[i] - needs[i] for i in range(len(needs))) >= 0, special))
        def dfs(cur):
            val = sum([price[i] * cur[i] for i in range(len(needs))])
            for spec in special:
                if val < spec[-1]:
                    continue
                tmp = [cur[i]-spec[i] for i in range(len(needs))]
                if min(tmp) >= 0:
                    val = min(
                        val, 
                        d.get(tuple(tmp), dfs(tmp))+ spec[-1]
                    )
            d[tuple(cur)] = val
            return val
        return dfs(needs)
        

695. Max Area of Island
class Solution(object):
#T:O(V) v is vertex that will traverse through, which is number 1
#S:O(n)
    def maxAreaOfIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        max_area = 0
        visited = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if (i,j) not in visited:
                        self.cur_area = 0
                        self.dfs(grid, i,j,visited)
                        max_area = max(max_area, self.cur_area)
        return max_area
    
    def dfs(self, grid, i, j,  visited):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1 and (i,j) not in visited:
            visited.add((i,j))
            self.cur_area += 1            
            self.dfs(grid,i+1, j,  visited)
            self.dfs(grid,i-1, j,  visited)
            self.dfs(grid,i, j+1,  visited)
            self.dfs(grid,i, j-1,  visited)

721. Accounts Merge
https://leetcode.com/problems/accounts-merge/
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        g = collections.defaultdict(list)
        res = []
        for i, account in enumerate(accounts):
            for j in range(1,len(account)):
                email = account[j]
                g[email].append(i)
        visited = [False for _ in range(len(accounts))]
        def dfs(i, emails):
            if visited[i]:
                return
            visited[i] = True
            for j in range(1, len(accounts[i])):
                email = accounts[i][j]
                emails.add(email)
                for nei in g[email]:
                    dfs(nei, emails)
        for i, account in enumerate(accounts):
            if visited[i]:
                continue
            emails = set()
            dfs(i,emails)    
            res.append([account[0]]+ sorted(emails))
        return res
###### union find ######
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        def find(a):
            if ds[a] < 0:
                return a
            ds[a] = find(ds[a])
            return ds[a]
        
        def union(a,b):
            a,b = find(a), find(b)
            if a != b:
                if ds[a] < ds[b]:
                    ds[a] += ds[b]
                    ds[a] = b
                else:
                    ds[b] += ds[a]
                    ds[b] = a
                    
        c, ds, email_to_id, id_to_name = 0, [], {}, {}
        for account in accounts:
            for email in account[1:]:
                if email not in email_to_id:
                    email_to_id[email] = c
                    id_to_name[c] = account[0]
                    ds.append(-1)
                    c+= 1
                union(email_to_id[account[1]], email_to_id[email])
        res = {}
        for email, id in email_to_id.items():
            master = find(id)
            res[master] = res.get(master,[]) + [email]
        return [[id_to_name[id]]+sorted(emails) for id, emails in res.items()]

733. Flood Fill
https://leetcode.com/problems/flood-fill/
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
#T:O(n)
#S:O(h)
        self.m, self.n = len(image), len(image[0])
        self.start_color = image[sr][sc]
        self.dfs(image, sr, sc, newColor)
        return image
    def dfs(self, image, i, j, newColor):
        if 0 <= i < self.m and 0 <= j < self.n:
            # tricky part is if newcolor is the same as the start_color, we need to skip 
            if image[i][j] == newColor or image[i][j] != self.start_color:
                return
            image[i][j] = newColor
            self.dfs(image, i+1, j, newColor)
            self.dfs(image, i-1, j, newColor)
            self.dfs(image, i, j+1, newColor)
            self.dfs(image, i, j-1, newColor)

749. Contain Virus
https://leetcode.com/problems/contain-virus/
class Solution(object):
    """
    思路：BFS
        1. 获取感染区、扩散区和墙数：获取感染区中所有点、及每个区域的扩散点、墙数
        2. 建墙：选取扩散点数最多的区域，统计墙数，建墙后墙内节点设置为安全区
        3. 扩散：其他区域的扩散点设为感染区
        4. 重复以上过程，直至没有感染区
    """
    def containVirus(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m,n = len(grid),len(grid[0])
        # this function is ued to generate adj node index
        def adj(i,j):
            for ii,jj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:
                if 0 <= ii < m and 0 <= jj< n:
                    yield ii,jj
        
        def get_virus_areas(grid):
            virus_areas = []
            dangers = []
            walls = []
            seen = [[0] * n for i in range(m)]
            
            for i in range(m):
                for j in range(n):
                    # this means we have virus in this node and never seen it in the past
                    if grid[i][j] == 1 and not seen[i][j]:
                        virus_area = [(i,j)]
                        danger = set()
                        wall = 0
                        Q = collections.deque([(i,j)])
                        seen[i][j] = 1
                        while Q:
                            s,t = Q.popleft()
                            for ii,jj in adj(s,t):
                                if grid[ii][jj] == 1 and not seen[ii][jj]:
                                    seen[ii][jj] = 1
                                    Q.append((ii,jj))
                                    virus_area.append((ii,jj))
                                if grid[ii][jj] == 0:
                                    wall += 1
                                    danger.add((ii,jj))
                        virus_areas.append(virus_area)
                        dangers.append(danger)
                        walls.append(wall)
            return virus_areas,dangers,walls
        
        def spread(dangers):
            for danger in dangers:
                for i,j in danger:
                    grid[i][j] = 1
        
        #virus_areas,dangers,walls = get_virus_areas(grid)
        
        wall_count = 0
        areas,dangers,walls = get_virus_areas(grid)
        #print(areas)
        #print(dangers)
        while areas:
            # 如果全是感染区，返回
            if sum(len(area) for area in areas) == m * n:
                return wall_count
            
            n_area = len(areas)
            # 获取危险点最多的区域
            dangerest_i = 0
            for i in range(n_area):
                if len(dangers[i]) > len(dangers[dangerest_i]):
                    dangerest_i = i
            
            # 建墙，统计墙数，将对应感染区变为安全区
            wall_count += walls[dangerest_i]
            for i,j in areas[dangerest_i]:
                grid[i][j] = -1
            
            # 其他感染区扩散
            spread(dangers[:dangerest_i] + dangers[dangerest_i+1:])
            
            # 重新获取感染区
            areas,dangers,walls = get_virus_areas(grid)
        
        return wall_count

797. All Paths From Source to Target
https://leetcode.com/problems/all-paths-from-source-to-target/
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        n = len(graph)-1
        gd = collections.defaultdict(list)
        for i, item in enumerate(graph):
            for x in item:
                gd[i].append(x)
        path = []
        
        def dfs(root, n, temp):
            if root == n:
                path.append(temp)
                return
            for nei in gd[root]:
                dfs(nei, n, temp+[nei])
        dfs(0, n, [0])    
        return path

841. Keys and Rooms
https://leetcode.com/problems/keys-and-rooms/
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        d = collections.defaultdict(list)
        self.res = 0
        visited =set()
        for i, key in enumerate(rooms):
            d[i] = key
        self.dfs(0,d,visited)
        return self.res == len(rooms)
    
    def dfs(self, rn, d, visited):
        if rn not in visited:
            self.res += 1
            visited.add(rn)
            for key in d[rn]:
                self.dfs(key, d, visited)
        return 

851. Loud and Rich
https://leetcode.com/problems/loud-and-rich/
class Solution:
#T:O(n)
#S:O(n)
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        morerich = collections.defaultdict(set)
        for i, j in richer: 
            morerich[j].add(i)
        res = []
        @lru_cache(maxsize=None)
        def dfs(i):
            cur, r = quiet[i], i
            if i not in morerich:
                return cur,r
            for rich in morerich[i]:
                cur1, r1 = dfs(rich)
                if cur1 < cur:
                    cur, r = cur1, r1
            return cur, r
        for i in range(len(quiet)): 
            res.append(dfs(i)[1])
        return res

897. Increasing Order Search Tree
https://leetcode.com/problems/increasing-order-search-tree/
class Solution:
#T:O(n)
#T:O(h)
    def increasingBST(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            l1, r2 = node, node
            if node.left:
                l1, l2 = dfs(node.left)
                l2.right = node
            if node.right:
                r1, r2 = dfs(node.right)
                node.right = r1
            node.left = None
            return (l1,r2)
        return dfs(root)[0]

934. Shortest Bridge
https://leetcode.com/problems/shortest-bridge/
class Solution:
    def shortestBridge(self, A: List[List[int]]) -> int:
        bound= set()
        dire = [(1,0),(-1,0),(0,1),(0,-1)]
        m, n = len(A), len(A[0])
        # get root of islanda
        def getfirst():
            for i in range(m):
                for j in range(n):
                    if A[i][j] == 1:
                        return i,j
        # get boundary of islanda
        def dfs(i,j):
            A[i][j] = -1
            for d in dire:
                x,y = i+d[0],j+d[1]
                if 0 <= x<m and 0 <= y < n:
                    if A[x][y] == 0:
                        bound.add((i,j))
                    elif A[x][y] == 1:
                        dfs(x,y)
        i,j = getfirst()
        dfs(i,j)
        # BFS to find next island
        step = 0
        while bound:
            new = []
            for i,j in bound:
                for d in dire:
                    x,y = i+d[0],j+d[1]
                    if 0 <= x < m and 0 <= y < n:
                        if A[x][y] == 1:
                            return step
                        elif A[x][y] ==0:
                            A[x][y] = -1
                            new.append((x,y))
            step += 1
            bound = new

947. Most Stones Removed with Same Row or Column
https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        seen = set()
        row, col = collections.defaultdict(list), collections.defaultdict(list)
        res = 0
        for i,j in stones:
            row[i].append(j)
            col[j].append(i)
        for i,j in stones:
            if (i,j) not in seen:
                self.dfs(i,j, row, col, seen)
                res += 1
        return len(stones)-res
    
    def dfs(self, i,j,row,col,seen):
        for jj in row[i]:
            if (i,jj) not in seen:
                seen.add((i,jj))
                self.dfs(i,jj,row,col,seen)
        for ii in col[j]:
            if (ii,j) not in seen:
                seen.add((ii,j))
                self.dfs(ii,j,row,col,seen)


959. Regions Cut By Slashes
https://leetcode.com/problems/regions-cut-by-slashes/
class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
        m, n = len(grid), len(grid[0])
        g = [[0 for x in range(3*n)] for y in range(3*m)]
        cnt = 0
        visited = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '/':
                    g[i*3][j*3+2] = 1
                    g[i*3+1][j*3+1] = 1
                    g[i*3+2][j*3] = 1
                elif grid[i][j] == '\\':
                    g[i*3][j*3] = 1
                    g[i*3+1][j*3+1] = 1
                    g[i*3+2][j*3+2] = 1
                
        for i in range(3*m):
            for j in range(3*n):
                if g[i][j] == 0:
                    if (i,j) not in visited:
                        self.dfs(g, i,j, visited)
                        cnt += 1
        return cnt 
    
    def dfs(self, g, i, j, visited):
        if 0 <= i < len(g) and 0 <= j < len(g[0]) and g[i][j] ==0 and (i,j) not in visited:
            visited.add((i,j))
            self.dfs(g,i+1,j,visited)
            self.dfs(g,i-1,j,visited)
            self.dfs(g,i,j+1,visited)
            self.dfs(g,i,j-1,visited)

990. Satisfiability of Equality Equations
https://leetcode.com/problems/satisfiability-of-equality-equations/
#######  DFS  #######
class Solution(object):
    def equationsPossible(self, equations):
        """
        :type equations: List[str]
        :rtype: bool
        """
        graph = collections.defaultdict(set)
        notEquals = []
        
        def canmeet(u,target, visited):
            if u == target:
                return True
            visited.add(u)
            for v in graph[u]:
                if v in visited:
                    continue
                if canmeet(v,target,visited):
                    return True
            return False
        for equ in equations:
            if equ[1:3] == '!=':
                a,b = equ.split('!=')
                notEquals.append((a,b))
            else:
                a,b = equ.split('==')
                graph[a].add(b)
                graph[b].add(a)
        for a, b in notEquals:
            if canmeet(a,b,set()):
                return False
        return True
        
 #######  Union Find  #######
 class UF(object):
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
            
    def connected(self, a, b):
        return self.find(a) == self.find(b)
class Solution(object):
    def equationsPossible(self, equations):
        """
        :type equations: List[str]
        :rtype: bool
        """
        uf = UF(26)
        equ, nonequ = [], []
        for a, e, _, b in equations:
            a,b = ord(a)-97, ord(b)-97
            if e == '=':
                equ.append((a,b))
            else:
                nonequ.append((a,b))
        for a, b in equ:
            uf.union(a,b)
        for a, b in nonequ:
            if uf.find(a) == uf.find(b):
                return False
        return True

1020. Number of Enclaves
https://leetcode.com/problems/number-of-enclaves/
class Solution:
    def numEnclaves(self, A: List[List[int]]) -> int:
        res = 0
        self.m,self.n = len(A), len(A[0])
        visited = set()
        for i in range(self.m):
            for j in range(self.n):
                if A[i][j] == 1 and (i,j) not in visited:
                    self.area = 0
                    if self.dfs(i,j,A,visited):
                        res += self.area 
        return res
    
    def dfs(self, i, j, A, visited):
        if i < 0 or j < 0 or i >= self.m or j >= self.n:
            return False
        if A[i][j] == 0:
            return True
        if (i,j) in visited:
            return True
        visited.add((i,j))
        self.area += 1
        top = self.dfs(i+1,j,A, visited)
        bot = self.dfs(i-1,j,A, visited)
        right = self.dfs(i,j+1,A, visited)
        left = self.dfs(i,j-1,A, visited)
        return top and bot and left and right

1059. All Paths from Source Lead to Destination
https://leetcode.com/problems/all-paths-from-source-lead-to-destination/
class Solution:
    def leadsToDestination(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        d = collections.defaultdict(list)    
        for a, b in edges:
            d[a].append(b)
        self.visited = [0 for _ in range(n)]
        return self.hasCycle(d,source, destination)
        
    def hasCycle(self, d, start,destination):
        # when len(d[start])==0, means this is a destination, just check 
        # whether it's our target destination
        if len(d[start])==0:
            return start == destination
        # if ==1, means we encounter a node that we have visited in current path,
        # this means we have a cycle in our graph
        elif self.visited[start] == 1:
            return False
        # if == 2: means we had visited this in the past, which we can skip to save
        # some time
        elif self.visited[start] == 2:
            return True
        else:
            # else, choose current node and mark it as 1, if not cycle found,
            # mark it as 2 means this node is visited and in the future if we meet
            # it again, we can skip it to save time since no cycle was detected here
            self.visited[start] = 1
            for nei in d[start]:
                if not self.hasCycle(d, nei, destination):
                    return False
            self.visited[start] = 2
            return True

1061. Lexicographically Smallest Equivalent String
https://leetcode.com/problems/lexicographically-smallest-equivalent-string/
class Solution:
    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:
        g = defaultdict(list)
        for a, b in zip(A, B):
            g[a].append(b)
            g[b].append(a)     
        smallest = {}
        for c in A:
            if c in smallest:
                continue
            equiv, least = self.findEquivalent(c,g)
            for e in equiv:
                smallest[e] = least
        return ''.join(smallest[c] if c in smallest else c for c in S)   
    
    def findEquivalent(self, u,g):
            self.seen = set()
            self.least = 'z'
            self.dfs(u,g) 
            return self.seen, self.least
    def dfs(self, u, g):
            if u in self.seen:
                return
            self.seen.add(u)
            self.least = min(self.least, u)
            for v in g[u]:
                self.dfs(v,g)

1102. Path With Maximum Minimum Value
https://leetcode.com/problems/path-with-maximum-minimum-value/
class Solution:
#Time: O(MN log MN)
#Space: O(MN)
    def maximumMinimumPath(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        dire = [(1,0),(-1,0),(0,1),(0,-1)]
        maxHeap = [(-A[0][0], 0, 0)]
        seen = set()
        while maxHeap:
            val, i, j = heapq.heappop(maxHeap)
            if i == m - 1 and j == n - 1: return -val
            for d in dire:
                x, y = i + d[0], j + d[1]
                if 0 <= x < m and 0 <= y < n and (x,y) not in seen:
                    seen.add((x,y)) # passed
                    # use a maxheap to keep the min value of current path and 
                    # next x,y, since maxheap will put bigger value in front 
                    # of queue, so always bigger value will get calculated first.
                    heapq.heappush(maxHeap, (max(val, -A[x][y]), x, y))
        return -1


1236. Web Crawler
https://leetcode.com/problems/web-crawler/

class Solution:
    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
        res = set()
        hostname = startUrl.split('/')[2]
        self.dfs(startUrl, res, htmlParser, hostname)
        return list(res)
    
    def dfs(self, starturl, res, htmlParser, hostname) :
        new_hostname = starturl.split('/')[2]
        if new_hostname != hostname:
            return
        if starturl not in res:
            res.add(starturl)
            for url in htmlParser.getUrls(starturl):
                self.dfs(url, res, htmlParser, hostname)
        return 

1273. Delete Tree Nodes
https://leetcode.com/problems/delete-tree-nodes/
class Solution:
#T:O(H)
#S:O(H)
    def deleteTreeNodes(self, nodes: int, parent: List[int], value: List[int]) -> int:
        # basic idea here is create a dict to map the tree
        children = collections.defaultdict(set)
        for i, j in enumerate(parent):
            children[j].add(i)
        # for each node, get its total number and total sum of that subtree
        # do dfs for each child, sum uo and if sum == 0, reutrn 00, else return normal
        def dfs(node):
            total_node = 1
            total_sum = value[node]
            for child in children[node]:
                child_sum, child_node = dfs(child)
                total_sum += child_sum
                total_node += child_node
                
            if total_sum==0:
                return 0,0
            else:
                return total_sum, total_node
        return dfs(0)[1]

1376. Time Needed to Inform All Employees
https://leetcode.com/problems/time-needed-to-inform-all-employees/
######################  bottom to top  ########################
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:

        def recurse(worker):
            # if manager[worker] == -1 means this is headID
            if manager[worker] != -1:
                # get its manager id and inform time add to current 
                # worker informatime
                informTime[worker] += recurse(manager[worker])
                # marked it as visited
                manager[worker] = -1
            # return informtime of worker
            return informTime[worker]
        # find the max time
        return max(map(recurse, manager))

######################  top to bottom  ########################
subordinates = collections.defaultdict(list)
        self.res = 0
        for i, v in enumerate(manager):
            subordinates[v].append(i)
        
        def dfs(manager, time):
            self.res = max(self.res, time)
            for subordinate in subordinates[manager]:
                dfs(subordinate, time + informTime[manager])
        dfs(headID, 0)        
        return self.res
        
1466. Reorder Routes to Make All Paths Lead to the City Zero
https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        d = collections.defaultdict(list)
        roads = set()
        self.res = 0
        for a,b in connections:
            d[a].append(b)
            d[b].append(a)
            roads.add((a,b))
        def dfs(u,parent):
            if (parent,u) in roads:
                self.res += 1
            for v in d[u]:
                if v == parent:
                    continue
                dfs(v,u)
        dfs(0,-1)
        return self.res

1625. Lexicographically Smallest String After Applying Operations
https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/
class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        def dfs(s):
            if s not in seen:
                seen.add(s)
                self.res = min(self.res, s)
                addA = list(s)
                for i,c in enumerate(addA):
                    if i % 2 == 1:
                        addA[i] = str((int(c)+a)%10)
                dfs(''.join(addA))
                dfs(s[-b :]+s[: -b])
        seen = set()
        self.res = s
        dfs(s)
        return self.res

1631. Path With Minimum Effort
https://leetcode.com/problems/path-with-minimum-effort/
https://leetcode.com/problems/path-with-minimum-effort/discuss/909017/JavaPython-Dijikstra-Clean-and-Concise-O(MNlogMN)
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m,n = len(heights), len(heights[0])
        dist = [[float('inf') for _ in range(n)]for _ in range(m)]
        min_heap = []
        min_heap.append((0, 0, 0))
        dire = [(1,0),(-1,0),(0,1),(0,-1)]
        while min_heap:
            d, r, c = heappop(min_heap)
            if d > dist[r][c]:
                continue
            if r == m-1 and c == n-1:
                return d
            for dd in dire:
                x,y = r + dd[0], c + dd[1]
                if 0 <= x < m and 0 <= y < n:
                    newdist = max(d, abs(heights[x][y]-heights[r][c]))
                    if dist[x][y]> newdist:
                        dist[x][y] = newdist
                        heappush(min_heap, (dist[x][y],x,y))
