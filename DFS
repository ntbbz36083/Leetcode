17. Letter Combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if not digits:
            return []
        d = {"2":"abc", "3":"def", "4":"ghi", "5":"jkl", "6":"mno", "7":"pqrs", "8":"tuv", "9":"wxyz"}
        res = []
        def dfs(index, path):
            if len(path)==len(digits):
                res.append(path)
            else:
                for c in d[digits[index]]:
                    dfs(index+1, path + c)        
        dfs(0, "")
        return res

46. Permutations
https://leetcode.com/problems/permutations/
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        visited = set()
        self.dfs(nums,visited, [], res)
        return res
    def dfs(self, nums, visited, path, res):
        if len(path) == len(nums):
            res.append(path)
        for i in range(len(nums)):
            if i not in visited:
                visited.add(i)
                self.dfs(nums, visited, path + [nums[i]], res)
                visited.remove(i)
                
51. N-Queens
https://leetcode.com/problems/n-queens/

class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        self.n = n
        res = []
        board = [["." for _ in range(n)] for _ in range(n)]
        self.backtrack(board, 0, res)
        return res
        
    def backtrack(self, board, row, res):
        if row == self.n:
            new = [''.join(x) for x in board]
            res.append(new)
            return
        for col in range(self.n):
            if self.isVaild(board, row, col):
                board[row][col] = 'Q'
                self.backtrack(board,row+1, res)
                board[row][col] = '.'

    def isVaild(self, board, row, col):
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        i,j=0,0
        for r, c in zip(range(row, -1, -1), range(col, -1, -1)):
            if board[r][c] == "Q":
                return False
        for r, c in zip(range(row, -1, -1), range(col, self.n)):
            if board[r][c] == "Q":
                return False
        return True
        
130. Surrounded Regions
#######  DFS  #######
https://leetcode.com/problems/surrounded-regions/
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return

        for i in [0, len(board)-1]:
            for j in range(len(board[0])):
                self.dfs(i,j,board)
        for i in range(len(board)):
            for j in [0, len(board[0])-1]:
                self.dfs(i,j,board)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == '.':
                    board[i][j] = 'O'
                    
    def dfs(self, i, j, board):
        if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == 'O':
            board[i][j] = '.'
            self.dfs(i+1,j, board)
            self.dfs(i-1,j, board)
            self.dfs(i,j+1, board)
            self.dfs(i,j-1, board)
            
#######  Union Find  #######
class UF(object):
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
            
    def connected(self, a, b):
        return self.find(a) == self.find(b)
        
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return
        m, n = len(board), len(board[0])
        uf = UF(m*n+1)
        
        for i in range(m):
            for j in [0,n-1]:
                if board[i][j] == 'O':
                    uf.union(i*n+j,m*n)
        for i in [0,m-1]:
            for j in range(n):
                if board[i][j] == 'O':
                    uf.union(i*n+j,m*n)
        
        d = [(1,0),(-1,0),(0,1), (0,-1)]
        for i in range(1,m-1):
            for j in range(1,n-1):
                if board[i][j] == 'O':
                    for dir in d:
                        x = i + dir[0]
                        y = j + dir[1]
                        if board[x][y] == 'O':
                            uf.union(i*n+j,x*n+y)
        for i in range(m):
            for j in range(n):
                if not uf.connected(i*n+j, m*n):
                    board[i][j] = 'X'

131. Palindrome Partitioning
https://leetcode.com/problems/palindrome-partitioning/
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        res = []
        self.dfs(s, [], res)
        return res
    
    def dfs(self, s, path, res):
        if not s:
            res.append(path)
            return
        for i in range(1,len(s)+1):
            if self.pal(s[:i]):
                self.dfs(s[i:], path + [s[:i]], res)
            
    def pal(self, s):
        return s == s[::-1]

200. Number of Islands
https://leetcode.com/problems/number-of-islands/
#######  DFS  #######
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        self.m, self.n = len(grid), len(grid[0])
        res = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == '1':
                    self.helper(grid, i, j)
                    res += 1
        return res    
    def helper(self, grid, i, j):
        if 0 <= i < self.m and 0 <= j < self.n and grid[i][j] == '1':
            grid[i][j] = '#'
            self.helper(grid,i+1, j)
            self.helper(grid,i-1, j)
            self.helper(grid,i, j+1)
            self.helper(grid,i, j-1)
            
#######  Union Find  #######
class UF(object):
    def __init__(self, m,n,grid):
        self.parent = [i for i in range(m*n)]
        self.rank = [0 for _ in range(m*n)]
        self.count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.count += 1
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
            
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
        self.count -= 1    
    def connected(self, a, b):
        return self.find(a) == self.find(b)
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if not grid:
            return 0        
        m, n = len(grid), len(grid[0])
        uf = UF(m,n,grid)
        d = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for dir in d:
                        x = i + dir[0]
                        y = j + dir[1]
                        if 0<= x < m and 0<= y < n and grid[x][y] == '1':
                            uf.union((i*n+j), (x*n+y))                            
        return uf.count    

207. Course Schedule
https://leetcode.com/problems/course-schedule/
class Solution:
#T:O(V+E), v is vetex number, E is egde number
#S:O(E)
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = collections.defaultdict(list)
        for p in prerequisites:
            x, y = p
            graph[x] += [y]
        visited = [0 for _ in range(numCourses)]
        for i in range(numCourses):
            if self.dfs(graph, visited, i):
                return False
        return True
    
    def dfs(self, graph, visited, i):
            if visited[i] == -1:
                return True
            if visited[i] == 1:
                return False
            visited[i] = -1
            for j in graph[i]:
                if self.dfs(graph, visited, j):
                    return False
            visited[i] = 1
            return False

210. Course Schedule II
https://leetcode.com/problems/course-schedule-ii/
class Solution:
#T:O(V+E), v is vetex number, E is egde number
#S:O(E)
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        visited = [0 for _ in range(numCourses)]
        res = []
        for p in prerequisites:
            x, y = p
            graph[x] += [y]
        for i in range(numCourses):
            if self.dfs(graph, visited, i, res):
                return []
        return res
    
    def dfs(self, graph, visited, i, res):
            if visited[i] == -1:
                return True
            if visited[i] == 1:
                return
            visited[i] = -1
            for j in graph[i]:
                if self.dfs(graph, visited, j, res):
                    return []
            res.append(i)
            visited[i] = 1


323. Number of Connected Components in an Undirected Graph
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/
#######  DFS  ######
class Solution(object):
    def countComponents(self, n, edges):
#T:O(E+V)
#S:O(n)
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        g = collections.defaultdict(list) #space O(n)
        visited = set() #space O(n)
        res = 0
        for edge in edges: #time O(e) edge number 
            g[edge[0]].append(edge[1])
            g[edge[1]].append(edge[0])
        for i in range(n): #not all visited, only those vertex O(v), worest O(n), best o(1)
            if i not in visited:
                self.dfs(i,g,visited)
                res += 1
        return res
    
    def dfs(self, vertex, g, visited):
        if vertex not in visited:
            visited.add(vertex)
            for nei in g[vertex]:
                self.dfs(nei, g, visited)

#######  Union Find  ######
class Solution(object):
    def countComponents(self, n, edges):
#T:O(E+V)
#S:O(n)
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        def find(a):
            while a != parent[a]:
                parent[a] = parent[parent[a]]
                a = parent[a]
            return a
        
        def union(a,b):
            a, b = find(a), find(b)
            if a != b:
                if parent[a] < parent[b]:
                    parent[a] = b
                    rank[b] += 1
                else:
                    parent[b] = a
                    rank[a] += 1
                    #if rank[a] == rank[b]:
                        #rank[a] += 1
        parent, rank = [i for i in range(n)], [0 for _ in range(n)]
        for e in edges:
            union(e[0], e[1])
        
        return len([0 for i in range(n) if i == parent[i]])

339. Nested List Weight Sum
https://leetcode.com/problems/nested-list-weight-sum/
class Solution:
#T:O(n) n is the number of all elements
#S:O(d) d us the depth of nestedlist
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        return self.dfs(nestedList, 1)
        
    
    def dfs(self, nestedList, depth):
        res = 0
        for item in nestedList:
            if item.isInteger():
                res += item.getInteger() * depth
            else:
                res +=self.dfs(item.getList(), depth+1)
        return res
        
364. Nested List Weight Sum II
https://leetcode.com/problems/nested-list-weight-sum-ii/
class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
        max_depth = self.getDepth(nestedList)
        self.res = 0
        self.dfs(nestedList, 0, max_depth)
        return self.res
    
    def dfs(self, nestedList, level, max_depth):
         for item in nestedList:
            if item.isInteger():
                self.res += item.getInteger() * (max_depth-level)
            else:
                self.dfs(item.getList(), level+1, max_depth)
            
    def getDepth(self, nestedList):
        depth = 1
        for item in nestedList:
            if not item.isInteger():
                depth = max(depth, self.getDepth(item.getList())+1)
        return depth

394. Decode String
https://leetcode.com/problems/decode-string/

526. Beautiful Arrangement
https://leetcode.com/problems/beautiful-arrangement/
class Solution:
    def countArrangement(self, n: int) -> int:
        self.count = 0
        visited = [False for _ in range(n+1)]
        self.dfs(visited,n,1)
        return self.count
    
    def dfs(self, visited,n,pos):
        if pos>n:
            self.count += 1
            return
        for i in range(1,n+1):
            if not visited[i] and (i % pos==0  or pos% i == 0):
                visited[i] = True
                self.dfs(visited,n,pos+1)
                visited[i] = False
    
529. Minesweeper
https://leetcode.com/problems/minesweeper/
class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        if not board:
            return []
        i,j = click[0], click[1]
        if board[i][j] == 'M':
            board[i][j] = 'X'
            return board
        
        self.m, self.n = len(board), len(board[0])
        self.dfs(board,i,j)
        return board
    
    def dfs(self, board, i, j):
        if board[i][j] != 'E':
            return
        directions = [(-1,-1), (0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0)]
        mine_count = 0
        for d in directions:
            x, y = i+d[0], j+d[1]
            if 0 <= x < self.m and 0 <= y < self.n and board[x][y] =='M':
                mine_count += 1
        if mine_count == 0:
            board[i][j] = 'B'
        else:
            board[i][j] = str(mine_count)
            return
        for d in directions:
            x, y = i+d[0], j+d[1]
            if 0 <= x < self.m and 0 <= y < self.n:
                self.dfs(board,x,y)
                
542. 01 Matrix
https://leetcode.com/problems/01-matrix/
#################################  BFS for each 1  ######################################
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix:
            return[]
        self.m, self.n = len(matrix), len(matrix[0])
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 1:
                    self.bfs(i,j,matrix)
        return matrix
    
    def bfs(self, i, j, matrix):
        q = collections.deque([(i,j,0)])
        while q:
            I,J, step = q.popleft()
            for x, y in [(I+1,J),(I-1,J),(I,J+1),(I,J-1)]: 
                if 0 <= x < self.m and 0 <= y < self.n:
                    if matrix[x][y] == 0:
                        matrix[i][j] = step+1
                        return
                    else:
                        q.append((x,y,step+1))

#################################  BFS for each 0  ######################################
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix:
            return[]
        self.m, self.n = len(matrix), len(matrix[0])
        q = collections.deque()
        visited = set()
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 0:
                    q.append((i,j))
                    visited.add((i, j))
                    
        while q:
            x,y = q.popleft()
            for r, c in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if (r,c) in visited:
                    continue 
                else:
                    if 0 <= r < self.m and 0 <= c < self.n:
                        matrix[r][c] = matrix[x][y] + 1
                        q.append((r,c))
                        visited.add((r,c))
        return matrix

547. Friend Circles
https://leetcode.com/problems/friend-circles/

576. Out of Boundary Paths
https://leetcode.com/problems/out-of-boundary-paths/
class Solution:
    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:
        mod = 10**9+7
        cache = collections.defaultdict(int)
        def helper(i,j,N):
            if (i,j,N) in cache:
                return cache[(i,j,N)]
            if 0 <= i < m and 0 <= j < n:
                if N ==0:
                    cache[(i,j,N)]=0
                    return cache[(i,j,N)]
                for x,y in [(i+1,j),(i-1,j),(i,j+1), (i,j-1)]:
                    cache[(i,j,N)] += helper(x,y,N-1)
                return cache[(i,j,N)] % mod
            else:
                cache[(i,j,N)]=1
                return cache[(i,j,N)]
        return helper(i,j,N) % mod

695. Max Area of Island
class Solution(object):
#T:O(V) v is vertex that will traverse through, which is number 1
#S:O(n)
    def maxAreaOfIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        max_area = 0
        visited = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if (i,j) not in visited:
                        self.cur_area = 0
                        self.dfs(grid, i,j,visited)
                        max_area = max(max_area, self.cur_area)
        return max_area
    
    def dfs(self, grid, i, j,  visited):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1 and (i,j) not in visited:
            visited.add((i,j))
            self.cur_area += 1            
            self.dfs(grid,i+1, j,  visited)
            self.dfs(grid,i-1, j,  visited)
            self.dfs(grid,i, j+1,  visited)
            self.dfs(grid,i, j-1,  visited)

721. Accounts Merge
https://leetcode.com/problems/accounts-merge/
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        g = collections.defaultdict(list)
        res = []
        for i, account in enumerate(accounts):
            for j in range(1,len(account)):
                email = account[j]
                g[email].append(i)
        visited = [False for _ in range(len(accounts))]
        def dfs(i, emails):
            if visited[i]:
                return
            visited[i] = True
            for j in range(1, len(accounts[i])):
                email = accounts[i][j]
                emails.add(email)
                for nei in g[email]:
                    dfs(nei, emails)
        for i, account in enumerate(accounts):
            if visited[i]:
                continue
            emails = set()
            dfs(i,emails)    
            res.append([account[0]]+ sorted(emails))
        return res
###### union find ######
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        def find(a):
            if ds[a] < 0:
                return a
            ds[a] = find(ds[a])
            return ds[a]
        
        def union(a,b):
            a,b = find(a), find(b)
            if a != b:
                if ds[a] < ds[b]:
                    ds[a] += ds[b]
                    ds[a] = b
                else:
                    ds[b] += ds[a]
                    ds[b] = a
                    
        c, ds, email_to_id, id_to_name = 0, [], {}, {}
        for account in accounts:
            for email in account[1:]:
                if email not in email_to_id:
                    email_to_id[email] = c
                    id_to_name[c] = account[0]
                    ds.append(-1)
                    c+= 1
                union(email_to_id[account[1]], email_to_id[email])
        res = {}
        for email, id in email_to_id.items():
            master = find(id)
            res[master] = res.get(master,[]) + [email]
        return [[id_to_name[id]]+sorted(emails) for id, emails in res.items()]

733. Flood Fill
https://leetcode.com/problems/flood-fill/
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
#T:O(n)
#S:O(h)
        self.m, self.n = len(image), len(image[0])
        self.start_color = image[sr][sc]
        self.dfs(image, sr, sc, newColor)
        return image
    def dfs(self, image, i, j, newColor):
        if 0 <= i < self.m and 0 <= j < self.n:
            # tricky part is if newcolor is the same as the start_color, we need to skip 
            if image[i][j] == newColor or image[i][j] != self.start_color:
                return
            image[i][j] = newColor
            self.dfs(image, i+1, j, newColor)
            self.dfs(image, i-1, j, newColor)
            self.dfs(image, i, j+1, newColor)
            self.dfs(image, i, j-1, newColor)
            
797. All Paths From Source to Target
https://leetcode.com/problems/all-paths-from-source-to-target/
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        n = len(graph)-1
        gd = collections.defaultdict(list)
        for i, item in enumerate(graph):
            for x in item:
                gd[i].append(x)
        path = []
        
        def dfs(root, n, temp):
            if root == n:
                path.append(temp)
                return
            for nei in gd[root]:
                dfs(nei, n, temp+[nei])
        dfs(0, n, [0])    
        return path

841. Keys and Rooms
https://leetcode.com/problems/keys-and-rooms/
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        d = collections.defaultdict(list)
        self.res = 0
        visited =set()
        for i, key in enumerate(rooms):
            d[i] = key
        self.dfs(0,d,visited)
        return self.res == len(rooms)
    
    def dfs(self, rn, d, visited):
        if rn not in visited:
            self.res += 1
            visited.add(rn)
            for key in d[rn]:
                self.dfs(key, d, visited)
        return 

897. Increasing Order Search Tree
https://leetcode.com/problems/increasing-order-search-tree/
class Solution:
#T:O(n)
#T:O(h)
    def increasingBST(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            l1, r2 = node, node
            if node.left:
                l1, l2 = dfs(node.left)
                l2.right = node
            if node.right:
                r1, r2 = dfs(node.right)
                node.right = r1
            node.left = None
            return (l1,r2)
        return dfs(root)[0]

959. Regions Cut By Slashes
https://leetcode.com/problems/regions-cut-by-slashes/
class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
        m, n = len(grid), len(grid[0])
        g = [[0 for x in range(3*n)] for y in range(3*m)]
        cnt = 0
        visited = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '/':
                    g[i*3][j*3+2] = 1
                    g[i*3+1][j*3+1] = 1
                    g[i*3+2][j*3] = 1
                elif grid[i][j] == '\\':
                    g[i*3][j*3] = 1
                    g[i*3+1][j*3+1] = 1
                    g[i*3+2][j*3+2] = 1
                
        for i in range(3*m):
            for j in range(3*n):
                if g[i][j] == 0:
                    if (i,j) not in visited:
                        self.dfs(g, i,j, visited)
                        cnt += 1
        return cnt 
    
    def dfs(self, g, i, j, visited):
        if 0 <= i < len(g) and 0 <= j < len(g[0]) and g[i][j] ==0 and (i,j) not in visited:
            visited.add((i,j))
            self.dfs(g,i+1,j,visited)
            self.dfs(g,i-1,j,visited)
            self.dfs(g,i,j+1,visited)
            self.dfs(g,i,j-1,visited)

990. Satisfiability of Equality Equations
https://leetcode.com/problems/satisfiability-of-equality-equations/
#######  DFS  #######
class Solution(object):
    def equationsPossible(self, equations):
        """
        :type equations: List[str]
        :rtype: bool
        """
        graph = collections.defaultdict(set)
        notEquals = []
        
        def canmeet(u,target, visited):
            if u == target:
                return True
            visited.add(u)
            for v in graph[u]:
                if v in visited:
                    continue
                if canmeet(v,target,visited):
                    return True
            return False
        for equ in equations:
            if equ[1:3] == '!=':
                a,b = equ.split('!=')
                notEquals.append((a,b))
            else:
                a,b = equ.split('==')
                graph[a].add(b)
                graph[b].add(a)
        for a, b in notEquals:
            if canmeet(a,b,set()):
                return False
        return True
        
 #######  Union Find  #######
 class UF(object):
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
            
    def connected(self, a, b):
        return self.find(a) == self.find(b)
class Solution(object):
    def equationsPossible(self, equations):
        """
        :type equations: List[str]
        :rtype: bool
        """
        uf = UF(26)
        equ, nonequ = [], []
        for a, e, _, b in equations:
            a,b = ord(a)-97, ord(b)-97
            if e == '=':
                equ.append((a,b))
            else:
                nonequ.append((a,b))
        for a, b in equ:
            uf.union(a,b)
        for a, b in nonequ:
            if uf.find(a) == uf.find(b):
                return False
        return True

1020. Number of Enclaves
https://leetcode.com/problems/number-of-enclaves/
class Solution:
    def numEnclaves(self, A: List[List[int]]) -> int:
        res = 0
        self.m,self.n = len(A), len(A[0])
        visited = set()
        for i in range(self.m):
            for j in range(self.n):
                if A[i][j] == 1 and (i,j) not in visited:
                    self.area = 0
                    if self.dfs(i,j,A,visited):
                        res += self.area 
        return res
    
    def dfs(self, i, j, A, visited):
        if i < 0 or j < 0 or i >= self.m or j >= self.n:
            return False
        if A[i][j] == 0:
            return True
        if (i,j) in visited:
            return True
        visited.add((i,j))
        self.area += 1
        top = self.dfs(i+1,j,A, visited)
        bot = self.dfs(i-1,j,A, visited)
        right = self.dfs(i,j+1,A, visited)
        left = self.dfs(i,j-1,A, visited)
        return top and bot and left and right

1061. Lexicographically Smallest Equivalent String
https://leetcode.com/problems/lexicographically-smallest-equivalent-string/
class Solution:
    def smallestEquivalentString(self, A: str, B: str, S: str) -> str:
        g = defaultdict(list)
        for a, b in zip(A, B):
            g[a].append(b)
            g[b].append(a)     
        smallest = {}
        for c in A:
            if c in smallest:
                continue
            equiv, least = self.findEquivalent(c,g)
            for e in equiv:
                smallest[e] = least
        return ''.join(smallest[c] if c in smallest else c for c in S)   
    
    def findEquivalent(self, u,g):
            self.seen = set()
            self.least = 'z'
            self.dfs(u,g) 
            return self.seen, self.least
    def dfs(self, u, g):
            if u in self.seen:
                return
            self.seen.add(u)
            self.least = min(self.least, u)
            for v in g[u]:
                self.dfs(v,g)

1236. Web Crawler
https://leetcode.com/problems/web-crawler/

class Solution:
    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
        res = set()
        hostname = startUrl.split('/')[2]
        self.dfs(startUrl, res, htmlParser, hostname)
        return list(res)
    
    def dfs(self, starturl, res, htmlParser, hostname) :
        new_hostname = starturl.split('/')[2]
        if new_hostname != hostname:
            return
        if starturl not in res:
            res.add(starturl)
            for url in htmlParser.getUrls(starturl):
                self.dfs(url, res, htmlParser, hostname)
        return 

1466. Reorder Routes to Make All Paths Lead to the City Zero
https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        d = collections.defaultdict(list)
        roads = set()
        self.res = 0
        for a,b in connections:
            d[a].append(b)
            d[b].append(a)
            roads.add((a,b))
        def dfs(u,parent):
            if (parent,u) in roads:
                self.res += 1
            for v in d[u]:
                if v == parent:
                    continue
                dfs(v,u)
        dfs(0,-1)
        return self.res
