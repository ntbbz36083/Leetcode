17. Letter Combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if not digits:
            return []
        d = {"2":"abc", "3":"def", "4":"ghi", "5":"jkl", "6":"mno", "7":"pqrs", "8":"tuv", "9":"wxyz"}
        res = []
        def dfs(index, path):
            if len(path)==len(digits):
                res.append(path)
            else:
                for c in d[digits[index]]:
                    dfs(index+1, path + c)        
        dfs(0, "")
        return res

46. Permutations
https://leetcode.com/problems/permutations/
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        visited = set()
        self.dfs(nums,visited, [], res)
        return res
    def dfs(self, nums, visited, path, res):
        if len(path) == len(nums):
            res.append(path)
        for i in range(len(nums)):
            if i not in visited:
                visited.add(i)
                self.dfs(nums, visited, path + [nums[i]], res)
                visited.remove(i)
                
51. N-Queens
https://leetcode.com/problems/n-queens/

class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        self.n = n
        res = []
        board = [["." for _ in range(n)] for _ in range(n)]
        self.backtrack(board, 0, res)
        return res
        
    def backtrack(self, board, row, res):
        if row == self.n:
            new = [''.join(x) for x in board]
            res.append(new)
            return
        for col in range(self.n):
            if self.isVaild(board, row, col):
                board[row][col] = 'Q'
                self.backtrack(board,row+1, res)
                board[row][col] = '.'

    def isVaild(self, board, row, col):
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        i,j=0,0
        for r, c in zip(range(row, -1, -1), range(col, -1, -1)):
            if board[r][c] == "Q":
                return False
        for r, c in zip(range(row, -1, -1), range(col, self.n)):
            if board[r][c] == "Q":
                return False
        return True
        
130. Surrounded Regions
#######  DFS  #######
https://leetcode.com/problems/surrounded-regions/
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return

        for i in [0, len(board)-1]:
            for j in range(len(board[0])):
                self.dfs(i,j,board)
        for i in range(len(board)):
            for j in [0, len(board[0])-1]:
                self.dfs(i,j,board)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == '.':
                    board[i][j] = 'O'
                    
    def dfs(self, i, j, board):
        if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == 'O':
            board[i][j] = '.'
            self.dfs(i+1,j, board)
            self.dfs(i-1,j, board)
            self.dfs(i,j+1, board)
            self.dfs(i,j-1, board)
            
#######  Union Find  #######
class UF(object):
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
            
    def connected(self, a, b):
        return self.find(a) == self.find(b)
        
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return
        m, n = len(board), len(board[0])
        uf = UF(m*n+1)
        
        for i in range(m):
            for j in [0,n-1]:
                if board[i][j] == 'O':
                    uf.union(i*n+j,m*n)
        for i in [0,m-1]:
            for j in range(n):
                if board[i][j] == 'O':
                    uf.union(i*n+j,m*n)
        
        d = [(1,0),(-1,0),(0,1), (0,-1)]
        for i in range(1,m-1):
            for j in range(1,n-1):
                if board[i][j] == 'O':
                    for dir in d:
                        x = i + dir[0]
                        y = j + dir[1]
                        if board[x][y] == 'O':
                            uf.union(i*n+j,x*n+y)
        for i in range(m):
            for j in range(n):
                if not uf.connected(i*n+j, m*n):
                    board[i][j] = 'X'

131. Palindrome Partitioning
https://leetcode.com/problems/palindrome-partitioning/
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        res = []
        self.dfs(s, [], res)
        return res
    
    def dfs(self, s, path, res):
        if not s:
            res.append(path)
            return
        for i in range(1,len(s)+1):
            if self.pal(s[:i]):
                self.dfs(s[i:], path + [s[:i]], res)
            
    def pal(self, s):
        return s == s[::-1]

200. Number of Islands
https://leetcode.com/problems/number-of-islands/
#######  DFS  #######
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        self.m, self.n = len(grid), len(grid[0])
        res = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == '1':
                    self.helper(grid, i, j)
                    res += 1
        return res    
    def helper(self, grid, i, j):
        if 0 <= i < self.m and 0 <= j < self.n and grid[i][j] == '1':
            grid[i][j] = '#'
            self.helper(grid,i+1, j)
            self.helper(grid,i-1, j)
            self.helper(grid,i, j+1)
            self.helper(grid,i, j-1)
            
#######  Union Find  #######
class UF(object):
    def __init__(self, m,n,grid):
        self.parent = [i for i in range(m*n)]
        self.rank = [0 for _ in range(m*n)]
        self.count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.count += 1
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
            
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
        self.count -= 1    
    def connected(self, a, b):
        return self.find(a) == self.find(b)
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if not grid:
            return 0        
        m, n = len(grid), len(grid[0])
        uf = UF(m,n,grid)
        d = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for dir in d:
                        x = i + dir[0]
                        y = j + dir[1]
                        if 0<= x < m and 0<= y < n and grid[x][y] == '1':
                            uf.union((i*n+j), (x*n+y))                            
        return uf.count    

323. Number of Connected Components in an Undirected Graph
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/
#######  DFS  ######
class Solution(object):
    def countComponents(self, n, edges):
#T:O(E+V)
#S:O(n)
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        g = collections.defaultdict(list) #space O(n)
        visited = set() #space O(n)
        res = 0
        for edge in edges: #time O(e) edge number 
            g[edge[0]].append(edge[1])
            g[edge[1]].append(edge[0])
        for i in range(n): #not all visited, only those vertex O(v), worest O(n), best o(1)
            if i not in visited:
                self.dfs(i,g,visited)
                res += 1
        return res
    
    def dfs(self, vertex, g, visited):
        if vertex not in visited:
            visited.add(vertex)
            for nei in g[vertex]:
                self.dfs(nei, g, visited)

#######  Union Find  ######
class Solution(object):
    def countComponents(self, n, edges):
#T:O(E+V)
#S:O(n)
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        def find(a):
            while a != parent[a]:
                parent[a] = parent[parent[a]]
                a = parent[a]
            return a
        
        def union(a,b):
            a, b = find(a), find(b)
            if a != b:
                if parent[a] < parent[b]:
                    parent[a] = b
                    rank[b] += 1
                else:
                    parent[b] = a
                    rank[a] += 1
                    #if rank[a] == rank[b]:
                        #rank[a] += 1
        parent, rank = [i for i in range(n)], [0 for _ in range(n)]
        for e in edges:
            union(e[0], e[1])
        
        return len([0 for i in range(n) if i == parent[i]])

394. Decode String
https://leetcode.com/problems/decode-string/



547. Friend Circles
https://leetcode.com/problems/friend-circles/


695. Max Area of Island
class Solution(object):
#T:O(V) v is vertex that will traverse through, which is number 1
#S:O(n)
    def maxAreaOfIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        max_area = 0
        visited = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if (i,j) not in visited:
                        self.cur_area = 0
                        self.dfs(grid, i,j,visited)
                        max_area = max(max_area, self.cur_area)
        return max_area
    
    def dfs(self, grid, i, j,  visited):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1 and (i,j) not in visited:
            visited.add((i,j))
            self.cur_area += 1            
            self.dfs(grid,i+1, j,  visited)
            self.dfs(grid,i-1, j,  visited)
            self.dfs(grid,i, j+1,  visited)
            self.dfs(grid,i, j-1,  visited)

721. Accounts Merge
https://leetcode.com/problems/accounts-merge/
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        g = collections.defaultdict(list)
        res = []
        for i, account in enumerate(accounts):
            for j in range(1,len(account)):
                email = account[j]
                g[email].append(i)
        visited = [False for _ in range(len(accounts))]
        def dfs(i, emails):
            if visited[i]:
                return
            visited[i] = True
            for j in range(1, len(accounts[i])):
                email = accounts[i][j]
                emails.add(email)
                for nei in g[email]:
                    dfs(nei, emails)
        for i, account in enumerate(accounts):
            if visited[i]:
                continue
            emails = set()
            dfs(i,emails)    
            res.append([account[0]]+ sorted(emails))
        return res
###### union find ######
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        def find(a):
            if ds[a] < 0:
                return a
            ds[a] = find(ds[a])
            return ds[a]
        
        def union(a,b):
            a,b = find(a), find(b)
            if a != b:
                if ds[a] < ds[b]:
                    ds[a] += ds[b]
                    ds[a] = b
                else:
                    ds[b] += ds[a]
                    ds[b] = a
                    
        c, ds, email_to_id, id_to_name = 0, [], {}, {}
        for account in accounts:
            for email in account[1:]:
                if email not in email_to_id:
                    email_to_id[email] = c
                    id_to_name[c] = account[0]
                    ds.append(-1)
                    c+= 1
                union(email_to_id[account[1]], email_to_id[email])
        res = {}
        for email, id in email_to_id.items():
            master = find(id)
            res[master] = res.get(master,[]) + [email]
        return [[id_to_name[id]]+sorted(emails) for id, emails in res.items()]
990. Satisfiability of Equality Equations
https://leetcode.com/problems/satisfiability-of-equality-equations/
#######  DFS  #######
class Solution(object):
    def equationsPossible(self, equations):
        """
        :type equations: List[str]
        :rtype: bool
        """
        graph = collections.defaultdict(set)
        notEquals = []
        
        def canmeet(u,target, visited):
            if u == target:
                return True
            visited.add(u)
            for v in graph[u]:
                if v in visited:
                    continue
                if canmeet(v,target,visited):
                    return True
            return False
        for equ in equations:
            if equ[1:3] == '!=':
                a,b = equ.split('!=')
                notEquals.append((a,b))
            else:
                a,b = equ.split('==')
                graph[a].add(b)
                graph[b].add(a)
        for a, b in notEquals:
            if canmeet(a,b,set()):
                return False
        return True
        
 #######  Union Find  #######
 class UF(object):
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        
    def find(self, p):
        while p != self.parent[p]:
            self.parent[p] = self.parent[self.parent[p]]
            p = self.parent[p]
        return p
    
    def union(self, a, b):
        i = self.find(a)
        j = self.find(b)
        if i == j:
            return
        if self.parent[i] <= self.parent[j]:
            self.rank[j] += 1
            self.parent[i] = self.parent[j]
        else:
            self.rank[i] += 1
            self.parent[j] = self.parent[i]
            
    def connected(self, a, b):
        return self.find(a) == self.find(b)
class Solution(object):
    def equationsPossible(self, equations):
        """
        :type equations: List[str]
        :rtype: bool
        """
        uf = UF(26)
        equ, nonequ = [], []
        for a, e, _, b in equations:
            a,b = ord(a)-97, ord(b)-97
            if e == '=':
                equ.append((a,b))
            else:
                nonequ.append((a,b))
        for a, b in equ:
            uf.union(a,b)
        for a, b in nonequ:
            if uf.find(a) == uf.find(b):
                return False
        return True
        
