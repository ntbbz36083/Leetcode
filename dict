36. Valid Sudoku
https://leetcode.com/problems/valid-sudoku/
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        return self.is_col_vaild(board) and self.is_row_vaild(board) and self.is_square_vaild(board)
    
    def is_unit_vaild(self, unit):
        # check whether there's repeated value
        unit = [i for i in unit if i != '.']
        return len(set(unit)) == len(unit)
    
    def is_row_vaild(self, board):
        for row in board:
            if not self.is_unit_vaild(row):
                return False
        return True
        
    def is_col_vaild(self, board):
        # use zip(*) to transpose matrix
        for col in zip(*board):
            if not self.is_unit_vaild(col):
                return False
        return True
        
    def is_square_vaild(self, board):
        for i in [0,3,6]:
            for j in [0,3,6]:
                square = []
                for x in range(i,i+3):
                    for y in range(j,j+3):
                        square.append(board[x][y])
                if not self.is_unit_vaild(square):
                    return False
        return True

49. Group Anagrams
https://leetcode.com/problems/group-anagrams/
#T:O(nlogn)
#S:O(n)

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = collections.defaultdict(list)
        for word in strs:
            key = tuple(sorted(word))
            d[key].append(word)
        return list(d.values())

136. Single Number
https://leetcode.com/problems/single-number/
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        c = collections.Counter(nums)
        for k,v in c.items():
            if v==1:
                return k

138. Copy List with Random Pointer
https://leetcode.com/problems/copy-list-with-random-pointer/
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        cloneHead = Node(-1)
        clone = cloneHead
        d = {None:None}
        cur = head
        
        while cur:
            clone.next = Node(cur.val)
            clone = clone.next
            d[cur] = clone
            cur = cur.next
        cur = head
        clone = cloneHead.next
        while cur:
            clone.random = d[cur.random]
            clone = clone.next
            cur = cur.next
        return cloneHead.next

166. Fraction to Recurring Decimal
https://leetcode.com/problems/fraction-to-recurring-decimal/
class Solution:
#T:O(n)
#S:O(n)
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator % denominator == 0:
            return str(numerator // denominator)
        sign = '' if numerator * denominator >= 0 else '-'
        numerator, denominator = abs(numerator), abs(denominator)
        res = sign + str(numerator//denominator) + '.'
        i, part = 0, ''
        d = {numerator:i}
        numerator %= denominator
        while numerator % denominator:
            numerator *= 10
            rem = numerator % denominator
            part += str(numerator // denominator)
            if rem in d:
                part = part[:d[rem]] + '(' + part[d[rem]:] + ')'
                return res + part
            i += 1
            d[rem] = i
            numerator = rem
        return res + part        


242. Valid Anagram
https://leetcode.com/problems/valid-anagram/
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        d = {}
        for ch in s:
            d[ch] = d.get(ch,0)+1
        for ch in t:
            d[ch] = d.get(ch,0)-1
        for v in d.values():
            if v != 0:
                return False
        return True

244. Shortest Word Distance II
https://leetcode.com/problems/shortest-word-distance-ii/
class WordDistance:

    def __init__(self, words: List[str]):
        self.d = collections.defaultdict(list)
        self.l = len(words)
        for i,word in enumerate(words):
            self.d[word].append(i)
            
    def shortest(self, word1: str, word2: str) -> int:
        l1, l2 = self.d[word1], self.d[word2]
        i = j = 0
        res = self.l
        # O(m+n) time complexity
        while i < len(l1) and j < len(l2):
            res = min(res, abs(l1[i]-l2[j]))
            if l1[i] < l2[j]:
                i += 1
            else:
                j += 1
        return res

246. Strobogrammatic Number
https://leetcode.com/problems/strobogrammatic-number/
class Solution:
    def isStrobogrammatic(self, num: str) -> bool:
        d = {'6':'9','9':'6','1':'1','8':'8','0':'0'}
        i,j = 0, len(num)-1
        while i<=j:
            if num[i] not in d or num[j] not in d:
                return False
            elif d[num[j]]!= num[i]:
                return False
            else:
                i+=1
                j-=1
        return True

249. Group Shifted Strings
#T:O(ab) where a is the total number of strings and b is the length of the longest string in strings.
#S:O(n) as the most space we would use is the space required for strings and the keys of our hashmap.

https://leetcode.com/problems/group-shifted-strings/
class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        hashmap = collections.defaultdict(list)
        for s in strings:
            key = []
            for i in range(len(s) - 1):
                circular_difference = ord(s[i+1]) - ord(s[i])
                key.append(str(circular_difference % 26))
            hashmap[','.join(key)].append(s)
        return hashmap.values()

266. Palindrome Permutation
https://leetcode.com/problems/palindrome-permutation/
class Solution:
    def canPermutePalindrome(self, s: str) -> bool:
        r = 0
        c = collections.Counter(s)
        for val in c.values():
            if val % 2 ==1:
                r += 1
        return r <=1

299. Bulls and Cows
https://leetcode.com/problems/bulls-and-cows/
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bull, cow = 0, 0
        # 2 countters here used to mem the possible cow chars
        s = collections.defaultdict(int) # secret hashtable
        g = collections.defaultdict(int) # guess hashtable
        
        for i in range(len(secret)):
            if secret[i] == guess[i]:
                bull += 1
            else:
                s[secret[i]] += 1
                g[guess[i]] += 1
        
        for k in s:
            if k in g:
                cow += min(s[k], g[k])
        
        return '{0}A{1}B'.format(bull, cow)

325. Maximum Size Subarray Sum Equals k
https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/
class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        ans, acc = 0, 0               # answer and the accumulative value of nums
        mp = {0:-1}                 #key is acc value, and value is the index
        for i in range(len(nums)):
            acc += nums[i]
            if acc not in mp:
                mp[acc] = i
            # acc-k in mp means there is a k inside acc now, subtract it from acc and get the old 
            # index, i-old index is the length of possible answer
            if acc-k in mp:
                ans = max(ans, i-mp[acc-k])
        return ans

350. Intersection of Two Arrays II
https://leetcode.com/problems/intersection-of-two-arrays-ii/
#### dict based solution
##T:O(m+n), m=len(nums1),n=len(nums2)
##S:O(m)
def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        c = collections.Counter(nums1)
        res = []
        for num in nums2:
            if num in c:
                c[num] -= 1
                res.append(num)
                if c[num] ==0:
                    del c[num]
        return res
        
#### 2 pointers based solution if arrays are sorted
##T:O(m+n), m=len(nums1),n=len(nums2), if sort needed, then O(m+n+logm+logn)
##S:O(1)
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        i,j = 0, 0
        res = []
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                res.append(nums1[i])
                i += 1
                j += 1
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return res
        
1.What if the given array is already sorted? How would you optimize your algorithm?
If 2 arrays are sorted, definitely go with 2 pointers method, which will save space from m->1
2.What if nums1's size is small compared to nums2's size? Which algorithm is better?
if nums1's size is smaller, then go with either should be fine. Dict solution doesn't need sort, which is a plus.
3.What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
if can't load all, then we can do trunk by trunk. We need to sort the data first, then load trunk of them and compare. Or using HDFS to store the data.  

359. Logger Rate Limiter
https://leetcode.com/problems/logger-rate-limiter/
class Logger:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if message not in self.d:
            self.d[message] = timestamp
            return True
        else:
            if timestamp >= self.d[message]+10:
                self.d[message] = timestamp
                return True
            else:
                return False


347. Top K Frequent Elements
https://leetcode.com/problems/top-k-frequent-elements/
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        res = []
        d = collections.Counter(nums)        
        max_heap = [(-val, key) for key, val in d.items()]
        heapq.heapify(max_heap)
        for i in range(k):
            res.append(heapq.heappop(max_heap)[1])
        return res

409. Longest Palindrome
https://leetcode.com/problems/longest-palindrome/
class Solution:
    def longestPalindrome(self, s: str) -> int:
        c = set()
        for ch in s:
            if ch in c:
                c.remove(ch)
            else:
                c.add(ch)
        return len(s)-len(c)+1 if len(c)>0 else len(s)

447. Number of Boomerangs
https://leetcode.com/problems/number-of-boomerangs/
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        res = 0
        #for each point, find its nei that has same distance
        for point1 in points:
            dmap = {}
            for point2 in points:
                d = (point1[0]-point2[0])**2 + (point1[1]-point2[1])**2
                dmap[d] = dmap.get(d,0) + 1
            for k in dmap:
                res += dmap[k] *(dmap[k]-1)
        return res

454. 4Sum II
https://leetcode.com/problems/4sum-ii/
class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        hashtable = {}
        count = 0 
        for a in A:
            for b in B :
                hashtable[a+b] = hashtable.get(a+b,0)+1        
        for c in C :
            for d in D :
                if -c - d in hashtable :
                    count += hashtable[-c-d]
        return count

463. Island Perimeter
https://leetcode.com/problems/island-perimeter/
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        self.res = 0
        self.m, self.n = len(grid), len(grid[0])
        visited = set()
        self.res = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == 1:
                    return self.dfs(grid, i, j, visited)
        return 0
                    
    def dfs(self, grid, i, j, visited):
        if (i,j) in visited:
            return 0
        if 0 <= i < self.m and 0 <= j < self.n and grid[i][j] == 1:
            visited.add((i,j))
            l = self.dfs(grid, i, j-1, visited)
            r = self.dfs(grid, i, j+1, visited)
            u = self.dfs(grid, i-1, j, visited)
            d = self.dfs(grid, i+1, j, visited)
            return l + r + u +d
        return 1

###########  set1 is subset of set2 if set1 <= set2 or just use issubset()  ###########
500. Keyboard Row
https://leetcode.com/problems/keyboard-row/
class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        line1, line2, line3 = set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')
        ret = []
        for word in words:
            w = set(word.lower())
            if w <= line1 or w <= line2 or w <= line3:
                ret.append(word)
        return ret

525. Contiguous Array
https://leetcode.com/problems/contiguous-array/
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        count = 0
        max_length=0
        table = {0: -1}
        for index, num in enumerate(nums):
            if num == 0:
                count -= 1
            else:
                count += 1
            
            if count in table:
                max_length = max(max_length, index - table[count])
            else:
                table[count] = index
        
        return max_length

535. Encode and Decode TinyURL
https://leetcode.com/problems/encode-and-decode-tinyurl/
https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/169879/3-Simple-Python-Solutions
class Codec:
    def __init__(self):
        self.code2url = {}
        self.url2code = {}
        
    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        letter_set = string.ascii_letters+string.digits
        while longUrl not in self.url2code:
            code = ''.join([random.choice(letter_set) for _ in range(6)])
            if code not in self.code2url:
                self.code2url[code] = longUrl
                self.url2code[longUrl] = code
        return 'http://tinyurl.com/'+self.url2code[longUrl]
    
    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        return self.code2url[shortUrl[-6:]]

554. Brick Wall
https://leetcode.com/problems/brick-wall/
class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        # the key idea here is using a dict to keep track of edges
        # more edges means less cross, we want to find max edges
        d = collections.defaultdict(int)
        max_edge = 0
        for line in wall:
            # use an accumulative i to count the wall length
            i = 0
            for brick in line[:-1]:
                i += brick
                d[i] += 1
                max_edge = max(max_edge, d[i])
        return len(wall)-max_edge

560. Subarray Sum Equals K
https://leetcode.com/problems/subarray-sum-equals-k/
class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        d = {0:1}
        su = 0
        res = 0
        for x in nums:
            su += x
            res += d.get(su-k,0)
            d[su] = d.get(su,0)+1
        return res

599. Minimum Index Sum of Two Lists
https://leetcode.com/problems/minimum-index-sum-of-two-lists/
class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        dic1, dic2 = {}, {}
        res_sum = len(list1)+len(list2)
        for i, s in enumerate(list1):
            dic1[s] = i
        for i, s in enumerate(list2):
            if s in dic1:
                tmp_sum = dic1[s] + i
                dic2[tmp_sum] = dic2.get(tmp_sum, []) + [s]
                res_sum = min(tmp_sum, res_sum)
        return dic2[res_sum]

######################  good follow-ups and for storage-related company  ######################
609. Find Duplicate File in System
https://leetcode.com/problems/find-duplicate-file-in-system/
https://leetcode.com/problems/find-duplicate-file-in-system/discuss/104120/Follow-up-questions-discussion
class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        c = collections.defaultdict(list)
        for path in paths:
            temp = path.split(' ')
            root_path = temp[0]
            files = temp[1:]
            for file in files:
                file_name, content = file.split('(')[0], file.split('(')[-1]
                c[content].append(''.join(root_path+'/'+file_name))
        return [x for x in c.values() if len(x)>1]


645. Set Mismatch
https://leetcode.com/problems/set-mismatch/
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        d = collections.Counter(nums)
        for i in range(1,len(nums)+1):
            if d[i] == 2:
                twice = i
            if i not in d:
                never = i
        return twice,never
        
648. Replace Words
https://leetcode.com/problems/replace-words/
class Trie():
    def __init__(self):
        self.root = {}
        
    def insert(self, word):
        cur = self.root
        for w in word:
            if w not in cur:
                cur[w] = {}
            cur = cur[w]
        cur['#'] = word
    
    def replace(self, word):
        cur = self.root
        for w in word:
            if '#' in cur:
                return cur['#']
            if w not in cur:
                return word
            cur = cur[w]  
        return word
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        t = Trie()
        res = []
        for word in dictionary:
            t.insert(word)
        for word in sentence.split(' '):
            res.append(t.replace(word))
        return ' '.join(res)

676. Implement Magic Dictionary
https://leetcode.com/problems/implement-magic-dictionary/
class MagicDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            self.d[len(word)] = self.d.get(len(word),[]) + [word]

    def search(self, searchWord: str) -> bool:
        for word in self.d.get(len(searchWord),[]):
            countdiff = 0
            for j in range(len(searchWord)):
                if word[j] != searchWord[j]:
                    countdiff += 1
            if countdiff == 1:
                return True
        return False

690. Employee Importance
https://leetcode.com/problems/employee-importance/
class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        emps = {employee.id: employee for employee in employees}
        def dfs(id):
            sub_imp = 0
            for sub in emps[id].subordinates:
                sub_imp += dfs(sub)
            return sub_imp + emps[id].importance
        return dfs(id)

692. Top K F
quent Wor
https://leetcode.com/problems/top-k-frequent-words/
class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        d = collections.Counter(words)
        max_heap = [(-val, key) for key, val in d.items()]
        heapq.heapify(max_heap)
        res = []
        while max_heap and k>0:
            res.append(heapq.heappop(max_heap)[1])
            k-=1
        return res

694. Number of Distinct Islands
https://leetcode.com/problems/number-of-distinct-islands/submissions/
#### solution1, with standard dfs by subtracting row and column number ####
class Solution:
    def numDistinctIslands(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        seen = set()
        distinctIslands = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    # 'o' for origin
                    self.steps = ''
                    self.helper(grid, i, j, 'o',seen)
                    print(self.steps)
                    distinctIslands.add(self.steps)
                    self.steps = ''
        print(distinctIslands)
        return len(distinctIslands)
    
    def helper(self, grid, i, j, direct,seen):
        if (i,j) in seen:
            return
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:
            self.steps += direct
            seen.add((i,j))
            self.helper(grid, i+1, j, 'd',seen)  # down
            self.helper(grid, i-1, j, 'u', seen)  # upper
            self.helper(grid, i, j+1, 'r', seen)  # right
            self.helper(grid, i, j-1, 'l', seen)  # left
            self.steps += 'b'  # back

#### solution1, with adding direct string ####
class Solution:
    def numDistinctIslands(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """        
        distinctIslands = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    # 'o' for origin
                    self.steps = ''
                    self.helper(grid, i, j, 'o')
                    distinctIslands.add(self.steps)
                    self.steps = ''
        return len(distinctIslands)
    
    def helper(self, grid, i, j, direct):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:
            self.steps += direct
            grid[i][j] = 0
            self.helper(grid, i+1, j, 'd')  # down
            self.helper(grid, i-1, j, 'u')  # upper
            self.helper(grid, i, j+1, 'r')  # right
            self.helper(grid, i, j-1, 'l')  # left
            self.steps += 'b'  # back

705. Design HashSet
https://leetcode.com/problems/design-hashset/
class MyHashSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.arr = [-1] * 100000

    def add(self, key: int) -> None:
        key = key % 100000
        self.arr[key] = 0
    def remove(self, key: int) -> None:
        key = key % 100000
        self.arr[key] = -1

    def contains(self, key: int) -> bool:
        """
        Returns true if this set contains the specified element
        """
        key = key % 100000
        return not self.arr[key] == -1


706. Design HashMap
https://leetcode.com/problems/design-hashmap/
class Node:
    def __init__(self, key=-1, val=-1, next=None):
        self.key = key
        self.val = val
        self.next = next

class MyHashMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = [Node() for _ in range(1000)]
    
    def hashcode(self,key):
        size = len(self.data)
        return key % size
    
    def put(self, key: int, value: int) -> None:
        """
        value will always be non-negative.
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                head.next.val = value
                return
            head = head.next
        head.next = Node(key,value)

    def get(self, key: int) -> int:
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                return head.next.val
            head = head.next
        return -1

    def remove(self, key: int) -> None:
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                tomove = head.next
                head.next = tomove.next
                tomove.next = None
                return
            head = head.next

#####################    learn how to use trie to sovle search word issue #####################
720. Longest Word in Dictionary
https://leetcode.com/problems/longest-word-in-dictionary/
https://leetcode.com/problems/longest-word-in-dictionary/discuss/203730/Python--%2B-DFS-(No-extensive-loops-or-complicated-TrieNode)
class TrieNode():
    def __init__(self):
        self.children = {}
        self.end = False
    
class Trie():
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.end = True
        
    def longest_word(self):
        def helper(node, partial_res):
            res = partial_res
            for c, child in node.children.items():
                if child.end:
                    po = helper(child, partial_res+c)
                    if len(po)>len(res):
                        res = po
                    elif len(po) == len(res) and po < res:
                        res = po
            return res
        return helper(self.root, '')

class Solution():
    def longestWord(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        t = Trie()
        for word in words:
            t.insert(word)
        return t.longest_word()

#####################    learn how to extract letter only by using isalpha() and counter can be subtracted by another counter #####################
748. Shortest Completing Word
https://leetcode.com/problems/shortest-completing-word/
class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        #d = Counter(x for x in licensePlate.lower() if x.isalpha())
        #return min([w for w in words if not d - Counter(w)], key = len)
        c = collections.Counter()
        res = []
        for x in licensePlate.lower():
            if x.isalpha():
                c[x] += 1
        for w in words:
            if not c-collections.Counter(w):
                res.append(w)
        return min(res,key=len)

739. Daily Temperatures
https://leetcode.com/problems/daily-temperatures/
#####################  stack  #####################
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        ans = [0]*len(T)
        stack = []
        for i, t in enumerate(T):
            while stack and T[stack[-1]] < t:
                cur = stack.pop()
                ans[cur] = i-cur
            stack.append(i)
        return ans
#####################  dict  #####################        
class Solution(object):
    def dailyTemperatures(self, temperatures):
        """
        :type temperatures: List[int]
        :rtype: List[int]
        """
        # Time: O(n.k), where k is the range of the temperature.
        # Space: O(n + k)
        temps = {}
        results = [0] * len(temperatures)
        for i in range(len(temperatures) - 1, -1, -1):
            temp = temperatures[i]
            day = str('inf')
            for j in range(temp + 1, 101):
                if j in temps:
                    day = min(day, temps[j] - i)
            if day != str('inf'):
                results[i] = day
            temps[temp] = i
        return results
771. Jewels and Stones
https://leetcode.com/problems/jewels-and-stones/
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        res = 0
        jew = set()
        for ch in jewels:
            jew.add(ch)
        for st in stones:
            if st in jew:
                res += 1
        return res

760. Find Anagram Mappings
https://leetcode.com/problems/find-anagram-mappings/
class Solution:
    def anagramMappings(self, A: List[int], B: List[int]) -> List[int]:
        d = {}
        for i,b in enumerate(B):
            d[b] = i
        return [d[a] for a in A]    
        

811. Subdomain Visit Count
https://leetcode.com/problems/subdomain-visit-count/
class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = {}
        for i in cpdomains:
            n, domains = i.split()
            n = int(n)
            domains = domains.split('.')
            for j in range(len(domains)):
                _str = '.'.join(domains[j:])
                d[_str] = d.get(_str,0) + n
        return [ str(d[i]) + ' ' + i for i in d ]

#####################    learn how to extract letter only by using re.findall(r'\w+',p) #####################
819. Most Common Word
https://leetcode.com/problems/most-common-word/
class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        d = {}
        ban = set(banned)
        words = re.findall(r'\w+', paragraph.lower())
        for word in words:
            if word not in ban:
                d[word] = d.get(word,0)+1
        m = max(d.values())
        for k,v in d.items():
            if v == m:
                return k

884. Uncommon Words from Two Sentences
https://leetcode.com/problems/uncommon-words-from-two-sentences/
class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        c = collections.Counter((A+' '+B).split(' '))
        return [k for k in c if c[k]==1]

930. Binary Subarrays With Sum
https://leetcode.com/problems/binary-subarrays-with-sum/class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        c = collections.Counter({0: 1})
        psum = res = 0
        for i in A:
            psum += i
            res += c[psum - S]
            c[psum] += 1
        return res

953. Verifying an Alien Dictionary
https://leetcode.com/problems/verifying-an-alien-dictionary/
class Solution(object):
#T:O(n)
#S:O(n)

    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        dic = {}
        for i, w in enumerate(order):
            dic[w] = i

        words = [[dic[c] for c in w] for w in words]    
        for w1, w2 in zip(words, words[1:]):
            if w1 > w2:
                return False
        return True

957. Prison Cells After N Days
https://leetcode.com/problems/prison-cells-after-n-days/
class Solution:
    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:
        #T:(27)
        #S:(15)
        def next_day(cell):
            #T:O(8)
            next_day = [0 for _ in range(8)]
            for i in range(1,len(cell)-1):
                if cell[i-1] == cell[i+1]:
                    next_day[i] = 1
                else:
                    next_day[i] = 0
            return next_day
        seen = {}
        while N > 0:
            c = tuple(cells)
            if c in seen:
                N %= seen[c]-N
            seen[c] = N
            
            if N >= 1:
                N -= 1
                cells = next_day(cells)
        return cells

961. N-Repeated Element in Size 2N Array
https://leetcode.com/problems/n-repeated-element-in-size-2n-array/
class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        d = {}
        for a in A:
            d[a] = d.get(a,0)+1
        for k,v in d.items():
            if v>1:
                return k

966. Vowel Spellchecker
https://leetcode.com/problems/vowel-spellchecker/
class Solution:
#T:O(4n)
#S:O(3n)
# first step check whether query in original word
# second step check whether in lower case word
# third step check whether in vowel sub word
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        words = {w: w for w in wordlist}
        cap = {w.lower(): w for w in wordlist[::-1]}
        vowel = {re.sub("[aeiou]", '#', w.lower()): w for w in wordlist[::-1]}
        return [words.get(w) or cap.get(w.lower()) or vowel.get(re.sub("[aeiou]", '#', w.lower()), "") for w in queries]

970. Powerful Integers
https://leetcode.com/problems/powerful-integers/
class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        res = set()
        stack = [(0,0)]
        while stack:
            i,j = stack.pop()
            temp = x**i+y**j
            if temp <= bound:
                res.add(temp)
                if x > 1:
                    stack.append((i+1,j))
                if y > 1:
                    stack.append((i,j+1))          
        return res

974. Subarray Sums Divisible by K
https://leetcode.com/problems/subarray-sums-divisible-by-k/
class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
        res = 0
        d = collections.defaultdict(int)
        d[0] = 1
        prefix = 0
        for num in A:
            prefix += num
            prefix %= K
            if prefix in d:
                res += d[prefix]
            d[prefix] += 1 
        return res

981. Time Based Key-Value Store
https://leetcode.com/problems/time-based-key-value-store/
class TimeMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.time = collections.defaultdict(list)
        self.value = collections.defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.time[key].append(timestamp)
        self.value[key].append(value)

    def get(self, key: str, timestamp: int) -> str:
        i = bisect.bisect(self.time[key], timestamp)
        return self.value[key][i-1] if i else ''

1002. Find Common Characters
https://leetcode.com/problems/find-common-characters/
class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        check = collections.Counter(A[0])
        for word in A[1:]:
            new_check = collections.Counter()
            for ch in word:
                if ch in check:
                    new_check[ch] += 1
                    check[ch] -= 1
                    if check[ch] == 0:
                        del check[ch]
            check = new_check
        res = []
        for key,val in check.items():
            for i in range(val):
                res.append(key)
        return res

1048. Longest String Chain
https://leetcode.com/problems/longest-string-chain/
class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        def dfs(word):
            #if this word doesn't exist in words, return 0
            if word not in dp:
                return 0
            #if it's never touched in the past, removing one char from it and find whether it's in words
            #find the max length from dp, +1 means add this word into it  
            if not dp[word]:
                dp[word] = max([dfs(word[:i]+word[i+1:]) + 1 for i in range(len(word))])
            # if it's already there with a value, we don't need to cal it and just return it's value
            return dp[word]
			
        dp = {word: None for word in words}
        # for each word find it's longest chain, return max
        return max([dfs(word) for word in dp])

1072. Flip Columns For Maximum Number of Equal Rows
https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/
class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        c = collections.Counter()
        for row in matrix:
            c[tuple(row)] += 1
            flip = [1-x for x in row]
            c[tuple(flip)] += 1
        return max(c.values())

1078. Occurrences After Bigram
https://leetcode.com/problems/occurrences-after-bigram/
class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        new = text.split(' ')
        res = []
        for i in range(2,len(new)):
            if new[i-2] == first and new[i-1] == second:
                res.append(new[i]) 
        return res

1086. High Five
https://leetcode.com/problems/high-five/
class Solution:
    def highFive(self, items: List[List[int]]) -> List[List[int]]:
        d = collections.defaultdict(list)
        for idx, val in items:
            heapq.heappush(d[idx],val)
            
            if len(d[idx])>5:
                heapq.heappop(d[idx])
                
        res = [[i,sum(d[i])//5] for i in sorted(d)]
        return res

1090. Largest Values From Labels
https://leetcode.com/problems/largest-values-from-labels/
class Solution:
    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:
        ct, res = 0, 0
        label_counts = collections.defaultdict(int)
        for val, label in sorted(zip(values,labels),reverse=True):
            if ct == num_wanted:
                break
            if label_counts[label] == use_limit:
                continue
            ct += 1
            res += val
            label_counts[label] += 1
        return res

1138. Alphabet Board Path
https://leetcode.com/problems/alphabet-board-path/
class Solution:
    def alphabetBoardPath(self, target: str) -> str:
        m = {w:(i//5,i%5) for i, w in enumerate('abcdefghijklmnopqrstuvwxyz')}
        #print(m)
        x0, y0 = 0,0
        res = []
        for c in target:
            x,y = m[c]
            if y < y0: res.append('L' *(y0-y))
            if x < x0: res.append('U' *(x0-x))
            if y > y0: res.append('R' *(y-y0))    
            if x > x0: res.append('D' *(x-x0))
            res.append('!')
            x0, y0 = x, y
        return ''.join(res)

1311. Get Watched Videos by Your Friends
https://leetcode.com/problems/get-watched-videos-by-your-friends/
class Solution:
#T:O(n+logn), bfs go through all nodes, which costs n, counter cost n, sorted cost logn
#S:O(V+n), v is width of bfs tree, counter cost n
 
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        def find_level_friend(lvl, ids, visited):
            if lvl == 0:
                return list(ids)
            ids_next_level = set()
            for i in ids:
                for j in friends[i]:
                    if j not in visited:
                        ids_next_level.add(j)
                        visited.add(j)
            return find_level_friend(lvl-1, list(ids_next_level), visited)
        
        friends_at_level = find_level_friend(level, [id], set([id]))
        counts = collections.Counter([vd for i in friends_at_level for vd in watchedVideos[i]])
        return sorted(counts, key = lambda x: (counts[x], x))

1133. Largest Unique Number
https://leetcode.com/problems/largest-unique-number/
class Solution:
    def largestUniqueNumber(self, A: List[int]) -> int:
        d = {}
        res = -1
        for a in A:
            d[a] = d.get(a,0)+1
        for k,v in d.items():
            if v == 1:
                res = max(res,k)
        return res

1152. Analyze User Website Visit Pattern
https://leetcode.com/problems/analyze-user-website-visit-pattern/
from collections import defaultdict
from itertools import combinations
class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        packed_tuple = zip(timestamp,username,website)  #[(3,'james', 'home'),...]
        sorted_packed_tuple = sorted(packed_tuple)  #sort by first element of tuple
        
        mapping = defaultdict(list)
        for t, u, w in sorted_packed_tuple:
            mapping[u].append(w)  #websites in list are in ascending order
            
        counter_dict = defaultdict(int)  ##counter to check the number of different comb
        for website_list in mapping.values():
            combs = set(combinations(website_list,3))  ##generate combinations of websites
            for comb in combs:
                counter_dict[comb] += 1
        res = sorted(counter_dict, key = lambda x:(-counter_dict[x], x))  ##sort counter dict and sort by number in descending first, then lexicographically 
        return res[0]

1160. Find Words That Can Be Formed by Characters
https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        su, ct = 0, collections.Counter
        ch = ct(chars)
        for word in words:
            wr = ct(word)
            if all(wr[i] <= ch[i] for i in wr):
                su += len(word)
        return su

1166. Design File System
https://leetcode.com/problems/design-file-system/
class FileSystem:

    def __init__(self):
        #self.d = {"":-1}
        self.d = {'':-1}

    def createPath(self, path: str, value: int) -> bool:
        parent = '/'.join(path.split('/')[:-1])
        if parent in self.d and path not in self.d:
            self.d[path] = value
            return True
        return False
            
    def get(self, path: str) -> int:
        return self.d.get(path,-1)


1189. Maximum Number of Balloons
https://leetcode.com/problems/maximum-number-of-balloons/
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        cnt = collections.Counter(text)
        cntBalloon = collections.Counter('balloon')
        res = []
        for c in cntBalloon:
            res.append(cnt[c]//cntBalloon[c])
        return min(res)

1207. Unique Number of Occurrences
https://leetcode.com/problems/unique-number-of-occurrences/class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = {}
        for ch in arr:
            d[ch] = d.get(ch,0)+1
        return len(d.values()) == len(set(d.values()))

1213. Intersection of Three Sorted Arrays
https://leetcode.com/problems/intersection-of-three-sorted-arrays/
class Solution:
    def arraysIntersection(self, arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]:
        d = {}
        res = []
        for a1 in arr1:
            d[a1] = d.get(a1,0)+1
        for a2 in arr2:
            d[a2] = d.get(a2,0)+1
        for a3 in arr3:
            d[a3] = d.get(a3,0)+1
        for k,v in d.items():
            if v == 3:
                res.append(k)
        return sorted(res)

1244. Design A Leaderboard
https://leetcode.com/problems/design-a-leaderboard/
class Leaderboard:

    def __init__(self):
        self.d = {}

    def addScore(self, playerId: int, score: int) -> None:
        if playerId in self.d:
            self.d[playerId] += score
        else:
            self.d[playerId] = score

    def top(self, K: int) -> int:
        self.stack = []
        heapq.heapify(self.stack)
        for v in self.d.values():
            heapq.heappush(self.stack, v)
            if len(self.stack)>K:
                heapq.heappop(self.stack)
        return sum(self.stack)            
    def reset(self, playerId: int) -> None:
        self.d[playerId] = 0


1261. Find Elements in a Contaminated Binary Tree
https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
class FindElements:

    def __init__(self, root: TreeNode):
        self.seen = set()
        
        def dfs(node, v):
            if node:
                node.val = v
                self.seen.add(v)
                dfs(node.left, 2*v+1)
                dfs(node.right, 2*v+2)
        dfs(root,0)    
    def find(self, target: int) -> bool:
        return target in self.seen

1365. How Many Numbers Are Smaller Than the Current Number
https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        d = {}
        for i, num in enumerate(sorted(nums)):
            if num not in d:
                d[num] = i
        return [d[num] for num in nums]        

1418. Display Table of Food Orders in a Restaurant
https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/
class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        d = collections.defaultdict(dict)
        meals = set()
        for _, table, food in orders:
            meals.add(food)
            if table in d:
                if food in d[table]:
                    d[table][food] += 1
                else:
                    d[table][food] = 1
            else:
                d[table] = {food:1} 
        #print(d)
        foods = sorted(meals)
        result = [['Table'] + [food for food in foods]]
        for table in sorted(d,key=int):
            temp = []
            for food in foods:
                if food in d[table]:
                    temp.append(str(d[table][food]))
                else:
                    temp.append('0')
            
            result.append([str(table)] + temp)
        return result

######################################################  more work needed  ######################################################
1429. First Unique Number
https://leetcode.com/problems/first-unique-number/


1487. Making File Names Unique
https://leetcode.com/problems/making-file-names-unique/
class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        used, d = set(), collections.defaultdict(int)
        res = []
        for name in names:
            k = d[name]
            cur = name
            while cur in used:
                k += 1
                cur = name + '(' + str(k) + ')'
            d[name] = k
            used.add(cur)
            res.append(cur)
        return res

1488. Avoid Flood in The City
https://leetcode.com/problems/avoid-flood-in-the-city/
class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        lake_stat = collections.defaultdict(bool)
        lastrain = collections.defaultdict(int)
        dry, res = [], []
        for k,v in enumerate(rains):
            # rains today
            if v >0:
                # if lake is empty, update it to full, update lastrain day of lake v to k
                if not lake_stat[v]:
                    lake_stat[v] = True
                    res.append(-1)
                    lastrain[v] = k
                # lake is full
                else:
                    # no dry day, return []
                    if dry == []:
                        return []
                    else:
                        #check if there's a dry day we can use
                        i, found = 0, False
                        while i < len(dry) and not found:
                            # any day that comes after lastrain[v], means we find it
                            if dry[i] > lastrain[v]:
                                found = True
                                dry_day = dry[i]
                            else:
                                i += 1
                        # if we find it, update res to v, lastrain to k,pop dry
                        if found:
                            res[dry_day] = v
                            lastrain[v] = k
                            dry.pop(i)
                            res.append(-1)
                        else:
                            return []
            # not rain, add dry day to dry        
            elif v == 0:
                res.append(1)
                dry.append(k)
        return res

1512. Number of Good Pairs
https://leetcode.com/problems/number-of-good-pairs/
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        d = {}
        res = 0
        for v in nums:
            if v in d:
                if d[v] == 1:
                    res += 1
                else:
                    res += d[v]
                d[v] += 1
            else:
                d[v] = 1
        return res

1539. Kth Missing Positive Number
https://leetcode.com/problems/kth-missing-positive-number/
good solution:https://leetcode.com/problems/kth-missing-positive-number/discuss/1004535/Python-Two-solutions-O(n)-and-O(log-n)-explained
class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        s = set(arr)
        for i in range(1,len(s)+k+1):
            if i not in s:
                k -= 1
            if k == 0:
                return i


1570. Dot Product of Two Sparse Vectors
https://leetcode.com/problems/dot-product-of-two-sparse-vectors/
class SparseVector:
#T:O(n+m)
#S:O(n)
    def __init__(self, nums: List[int]):
        self.seen = {}
        for i, num in enumerate(nums):
            if num:
                self.seen[i] = num

    # Return the dotProduct of two sparse vectors
    def dotProduct(self, vec: 'SparseVector') -> int:
        res = 0
        if len(self.seen) >= len(vec.seen):
            A,B = vec.seen, self.seen
        else:
            A,B = self.seen, vec.seen
        for j, num in A.items():
            if j in B:
                res += num * B[j]
        return res

1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers
https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/
class Solution:
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        d1 = collections.Counter([i*i for i in nums1])
        d2 = collections.Counter([i*i for i in nums2])
        res = 0
        for i in range(len(nums1) - 1):
            for j in range(i + 1, len(nums1)):
                p = nums1[i] * nums1[j]
                if p in d2:
                    res += d2[p]
        for i in range(len(nums2) - 1):
            for j in range(i + 1, len(nums2)):
                p = nums2[i] * nums2[j]
                if p in d1:
                    res += d1[p]
        return res

1590. Make Sum Divisible by P
https://leetcode.com/problems/make-sum-divisible-by-p/
https://leetcode.com/problems/make-sum-divisible-by-p/discuss/854166/JavaPython-3-O(n)-code-w-brief-explanation-analysis-and-similar-problems.
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        need, min_len, prefix_sum = sum(nums) % p, len(nums), 0
        prefix_sum_to_index = {prefix_sum : -1}
        for i, num in enumerate(nums):
            prefix_sum = (prefix_sum + num) % p
            prefix_sum_to_index[prefix_sum] = i
            key = (prefix_sum - need) % p
            if key in prefix_sum_to_index:
                min_len = min(min_len, i - prefix_sum_to_index[key])
        return min_len if min_len < len(nums) else -1

1638. Count Substrings That Differ by One Character
https://leetcode.com/problems/count-substrings-that-differ-by-one-character/
class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        d = collections.defaultdict(list)
        for i in range(len(s)+1):
            for j in range(i):
                substring = s[j:i]
                if len(substring):
                    for k in range(len(substring)):
                        n = substring[:k]+'*'+substring[k+1:]
                        d[n].append(substring)
        count = 0
        for i in range(len(t)+1):
            for j in range(i):
                substring = t[j:i]
                if len(substring):
                    for k in range(len(substring)):
                        n = substring[:k]+'*'+substring[k+1:]
                        if d[n]:
                            chances = d[n]
                            c = collections.Counter(chances)
                            for sub in c:
                                if substring != sub:
                                    count += c[sub]
        return count

1679. Max Number of K-Sum Pairs
https://leetcode.com/problems/max-number-of-k-sum-pairs/
class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        c = collections.Counter(nums)
        res = 0 
        for key in c:
            if c.get(k - key):
                if k - key == key:
                    res += c[key]//2
                    c[key] -= c[key]//2
                else:
                    m = min(c[key], c[k-key])
                    c[key] -= m
                    c[k-key] -= m
                    res += m
        return res                

1711. Count Good Meals
https://leetcode.com/problems/count-good-meals/
class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        ans = 0
        freq = defaultdict(int)
        for x in deliciousness: 
            for k in range(22): 
                ans += freq[2**k - x]
            freq[x] += 1
        return ans % 1_000_000_007
        
