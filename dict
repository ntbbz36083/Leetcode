49. Group Anagrams
https://leetcode.com/problems/group-anagrams/
#T:O(nlogn)
#S:O(n)

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = collections.defaultdict(list)
        for word in strs:
            key = tuple(sorted(word))
            d[key].append(word)
        return list(d.values())

136. Single Number
https://leetcode.com/problems/single-number/
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        c = collections.Counter(nums)
        for k,v in c.items():
            if v==1:
                return k

138. Copy List with Random Pointer
https://leetcode.com/problems/copy-list-with-random-pointer/
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        cloneHead = Node(-1)
        clone = cloneHead
        d = {None:None}
        cur = head
        
        while cur:
            clone.next = Node(cur.val)
            clone = clone.next
            d[cur] = clone
            cur = cur.next
        cur = head
        clone = cloneHead.next
        while cur:
            clone.random = d[cur.random]
            clone = clone.next
            cur = cur.next
        return cloneHead.next

242. Valid Anagram
https://leetcode.com/problems/valid-anagram/
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        d = {}
        for ch in s:
            d[ch] = d.get(ch,0)+1
        for ch in t:
            d[ch] = d.get(ch,0)-1
        for v in d.values():
            if v != 0:
                return False
        return True

266. Palindrome Permutation
https://leetcode.com/problems/palindrome-permutation/
class Solution:
    def canPermutePalindrome(self, s: str) -> bool:
        r = 0
        c = collections.Counter(s)
        for val in c.values():
            if val % 2 ==1:
                r += 1
        return r <=1

359. Logger Rate Limiter
https://leetcode.com/problems/logger-rate-limiter/
class Logger:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if message not in self.d:
            self.d[message] = timestamp
            return True
        else:
            if timestamp >= self.d[message]+10:
                self.d[message] = timestamp
                return True
            else:
                return False


347. Top K Frequent Elements
https://leetcode.com/problems/top-k-frequent-elements/
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        res = []
        d = collections.Counter(nums)        
        max_heap = [(-val, key) for key, val in d.items()]
        heapq.heapify(max_heap)
        for i in range(k):
            res.append(heapq.heappop(max_heap)[1])
        return res

463. Island Perimeter
https://leetcode.com/problems/island-perimeter/
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        self.res = 0
        self.m, self.n = len(grid), len(grid[0])
        visited = set()
        self.res = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == 1:
                    return self.dfs(grid, i, j, visited)
        return 0
                    
    def dfs(self, grid, i, j, visited):
        if (i,j) in visited:
            return 0
        if 0 <= i < self.m and 0 <= j < self.n and grid[i][j] == 1:
            visited.add((i,j))
            l = self.dfs(grid, i, j-1, visited)
            r = self.dfs(grid, i, j+1, visited)
            u = self.dfs(grid, i-1, j, visited)
            d = self.dfs(grid, i+1, j, visited)
            return l + r + u +d
        return 1

###########  set1 is subset of set2 if set1 <= set2 or just use issubset()  ###########
500. Keyboard Row
https://leetcode.com/problems/keyboard-row/
class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        line1, line2, line3 = set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')
        ret = []
        for word in words:
            w = set(word.lower())
            if w <= line1 or w <= line2 or w <= line3:
                ret.append(word)
        return ret

560. Subarray Sum Equals K
https://leetcode.com/problems/subarray-sum-equals-k/
class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        d = {0:1}
        su = 0
        res = 0
        for x in nums:
            su += x
            res += d.get(su-k,0)
            d[su] = d.get(su,0)+1
        return res

690. Employee Importance
https://leetcode.com/problems/employee-importance/
class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        emps = {employee.id: employee for employee in employees}
        def dfs(id):
            sub_imp = 0
            for sub in emps[id].subordinates:
                sub_imp += dfs(sub)
            return sub_imp + emps[id].importance
        return dfs(id)

692. Top K F
quent Wor
https://leetcode.com/problems/top-k-frequent-words/
class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        d = collections.Counter(words)
        max_heap = [(-val, key) for key, val in d.items()]
        heapq.heapify(max_heap)
        res = []
        while max_heap and k>0:
            res.append(heapq.heappop(max_heap)[1])
            k-=1
        return res

705. Design HashSet
https://leetcode.com/problems/design-hashset/
class MyHashSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.arr = [-1] * 100000

    def add(self, key: int) -> None:
        key = key % 100000
        self.arr[key] = 0
    def remove(self, key: int) -> None:
        key = key % 100000
        self.arr[key] = -1

    def contains(self, key: int) -> bool:
        """
        Returns true if this set contains the specified element
        """
        key = key % 100000
        return not self.arr[key] == -1


706. Design HashMap
https://leetcode.com/problems/design-hashmap/
class Node:
    def __init__(self, key=-1, val=-1, next=None):
        self.key = key
        self.val = val
        self.next = next

class MyHashMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = [Node() for _ in range(1000)]
    
    def hashcode(self,key):
        size = len(self.data)
        return key % size
    
    def put(self, key: int, value: int) -> None:
        """
        value will always be non-negative.
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                head.next.val = value
                return
            head = head.next
        head.next = Node(key,value)

    def get(self, key: int) -> int:
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                return head.next.val
            head = head.next
        return -1

    def remove(self, key: int) -> None:
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                tomove = head.next
                head.next = tomove.next
                tomove.next = None
                return
            head = head.next

#####################    learn how to extract letter only by using isalpha() and counter can be subtracted by another counter #####################
748. Shortest Completing Word
https://leetcode.com/problems/shortest-completing-word/
class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        #d = Counter(x for x in licensePlate.lower() if x.isalpha())
        #return min([w for w in words if not d - Counter(w)], key = len)
        c = collections.Counter()
        res = []
        for x in licensePlate.lower():
            if x.isalpha():
                c[x] += 1
        for w in words:
            if not c-collections.Counter(w):
                res.append(w)
        return min(res,key=len)

771. Jewels and Stones
https://leetcode.com/problems/jewels-and-stones/
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        res = 0
        jew = set()
        for ch in jewels:
            jew.add(ch)
        for st in stones:
            if st in jew:
                res += 1
        return res

760. Find Anagram Mappings
https://leetcode.com/problems/find-anagram-mappings/
class Solution:
    def anagramMappings(self, A: List[int], B: List[int]) -> List[int]:
        d = {}
        for i,b in enumerate(B):
            d[b] = i
        return [d[a] for a in A]    
        

811. Subdomain Visit Count
https://leetcode.com/problems/subdomain-visit-count/
class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = {}
        for i in cpdomains:
            n, domains = i.split()
            n = int(n)
            domains = domains.split('.')
            for j in range(len(domains)):
                _str = '.'.join(domains[j:])
                d[_str] = d.get(_str,0) + n
        return [ str(d[i]) + ' ' + i for i in d ]

#####################    learn how to extract letter only by using re.findall(r'\w+',p) #####################
819. Most Common Word
https://leetcode.com/problems/most-common-word/
class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        d = {}
        ban = set(banned)
        words = re.findall(r'\w+', paragraph.lower())
        for word in words:
            if word not in ban:
                d[word] = d.get(word,0)+1
        m = max(d.values())
        for k,v in d.items():
            if v == m:
                return k

884. Uncommon Words from Two Sentences
https://leetcode.com/problems/uncommon-words-from-two-sentences/
class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        c = collections.Counter((A+' '+B).split(' '))
        return [k for k in c if c[k]==1]


953. Verifying an Alien Dictionary
https://leetcode.com/problems/verifying-an-alien-dictionary/
class Solution(object):
#T:O(n)
#S:O(n)

    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        dic = {}
        for i, w in enumerate(order):
            dic[w] = i

        words = [[dic[c] for c in w] for w in words]    
        for w1, w2 in zip(words, words[1:]):
            if w1 > w2:
                return False
        return True

961. N-Repeated Element in Size 2N Array
https://leetcode.com/problems/n-repeated-element-in-size-2n-array/
class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        d = {}
        for a in A:
            d[a] = d.get(a,0)+1
        for k,v in d.items():
            if v>1:
                return k

981. Time Based Key-Value Store
https://leetcode.com/problems/time-based-key-value-store/
class TimeMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.time = collections.defaultdict(list)
        self.value = collections.defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.time[key].append(timestamp)
        self.value[key].append(value)

    def get(self, key: str, timestamp: int) -> str:
        i = bisect.bisect(self.time[key], timestamp)
        return self.value[key][i-1] if i else ''

1002. Find Common Characters
https://leetcode.com/problems/find-common-characters/
class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        check = collections.Counter(A[0])
        for word in A[1:]:
            new_check = collections.Counter()
            for ch in word:
                if ch in check:
                    new_check[ch] += 1
                    check[ch] -= 1
                    if check[ch] == 0:
                        del check[ch]
            check = new_check
        res = []
        for key,val in check.items():
            for i in range(val):
                res.append(key)
        return res

1078. Occurrences After Bigram
https://leetcode.com/problems/occurrences-after-bigram/
class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        new = text.split(' ')
        res = []
        for i in range(2,len(new)):
            if new[i-2] == first and new[i-1] == second:
                res.append(new[i]) 
        return res

1086. High Five
https://leetcode.com/problems/high-five/
class Solution:
    def highFive(self, items: List[List[int]]) -> List[List[int]]:
        d = collections.defaultdict(list)
        for idx, val in items:
            heapq.heappush(d[idx],val)
            
            if len(d[idx])>5:
                heapq.heappop(d[idx])
                
        res = [[i,sum(d[i])//5] for i in sorted(d)]
        return res

1133. Largest Unique Number
https://leetcode.com/problems/largest-unique-number/
class Solution:
    def largestUniqueNumber(self, A: List[int]) -> int:
        d = {}
        res = -1
        for a in A:
            d[a] = d.get(a,0)+1
        for k,v in d.items():
            if v == 1:
                res = max(res,k)
        return res

1152. Analyze User Website Visit Pattern
https://leetcode.com/problems/analyze-user-website-visit-pattern/
from collections import defaultdict
from itertools import combinations
class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        packed_tuple = zip(timestamp,username,website)  #[(3,'james', 'home'),...]
        sorted_packed_tuple = sorted(packed_tuple)  #sort by first element of tuple
        
        mapping = defaultdict(list)
        for t, u, w in sorted_packed_tuple:
            mapping[u].append(w)  #websites in list are in ascending order
            
        counter_dict = defaultdict(int)  ##counter to check the number of different comb
        for website_list in mapping.values():
            combs = set(combinations(website_list,3))  ##generate combinations of websites
            for comb in combs:
                counter_dict[comb] += 1
        res = sorted(counter_dict, key = lambda x:(-counter_dict[x], x))  ##sort counter dict and sort by number in descending first, then lexicographically 
        return res[0]

1160. Find Words That Can Be Formed by Characters
https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        su, ct = 0, collections.Counter
        ch = ct(chars)
        for word in words:
            wr = ct(word)
            if all(wr[i] <= ch[i] for i in wr):
                su += len(word)
        return su
        
1189. Maximum Number of Balloons
https://leetcode.com/problems/maximum-number-of-balloons/
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        cnt = collections.Counter(text)
        cntBalloon = collections.Counter('balloon')
        res = []
        for c in cntBalloon:
            res.append(cnt[c]//cntBalloon[c])
        return min(res)

1207. Unique Number of Occurrences
https://leetcode.com/problems/unique-number-of-occurrences/class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = {}
        for ch in arr:
            d[ch] = d.get(ch,0)+1
        return len(d.values()) == len(set(d.values()))

1213. Intersection of Three Sorted Arrays
https://leetcode.com/problems/intersection-of-three-sorted-arrays/
class Solution:
    def arraysIntersection(self, arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]:
        d = {}
        res = []
        for a1 in arr1:
            d[a1] = d.get(a1,0)+1
        for a2 in arr2:
            d[a2] = d.get(a2,0)+1
        for a3 in arr3:
            d[a3] = d.get(a3,0)+1
        for k,v in d.items():
            if v == 3:
                res.append(k)
        return sorted(res)
        

1365. How Many Numbers Are Smaller Than the Current Number
https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        d = {}
        for i, num in enumerate(sorted(nums)):
            if num not in d:
                d[num] = i
        return [d[num] for num in nums]        

1512. Number of Good Pairs
https://leetcode.com/problems/number-of-good-pairs/
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        d = {}
        res = 0
        for v in nums:
            if v in d:
                if d[v] == 1:
                    res += 1
                else:
                    res += d[v]
                d[v] += 1
            else:
                d[v] = 1
        return res

1539. Kth Missing Positive Number
https://leetcode.com/problems/kth-missing-positive-number/
good solution:https://leetcode.com/problems/kth-missing-positive-number/discuss/1004535/Python-Two-solutions-O(n)-and-O(log-n)-explained
class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        s = set(arr)
        for i in range(1,len(s)+k+1):
            if i not in s:
                k -= 1
            if k == 0:
                return i
