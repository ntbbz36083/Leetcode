49. Group Anagrams
https://leetcode.com/problems/group-anagrams/
#T:O(nlogn)
#S:O(n)

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = collections.defaultdict(list)
        for word in strs:
            key = tuple(sorted(word))
            d[key].append(word)
        return list(d.values())

136. Single Number
https://leetcode.com/problems/single-number/
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        c = collections.Counter(nums)
        for k,v in c.items():
            if v==1:
                return k

138. Copy List with Random Pointer
https://leetcode.com/problems/copy-list-with-random-pointer/
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        cloneHead = Node(-1)
        clone = cloneHead
        d = {None:None}
        cur = head
        
        while cur:
            clone.next = Node(cur.val)
            clone = clone.next
            d[cur] = clone
            cur = cur.next
        cur = head
        clone = cloneHead.next
        while cur:
            clone.random = d[cur.random]
            clone = clone.next
            cur = cur.next
        return cloneHead.next

242. Valid Anagram
https://leetcode.com/problems/valid-anagram/
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        d = {}
        for ch in s:
            d[ch] = d.get(ch,0)+1
        for ch in t:
            d[ch] = d.get(ch,0)-1
        for v in d.values():
            if v != 0:
                return False
        return True

246. Strobogrammatic Number
https://leetcode.com/problems/strobogrammatic-number/
class Solution:
    def isStrobogrammatic(self, num: str) -> bool:
        d = {'6':'9','9':'6','1':'1','8':'8','0':'0'}
        i,j = 0, len(num)-1
        while i<=j:
            if num[i] not in d or num[j] not in d:
                return False
            elif d[num[j]]!= num[i]:
                return False
            else:
                i+=1
                j-=1
        return True

266. Palindrome Permutation
https://leetcode.com/problems/palindrome-permutation/
class Solution:
    def canPermutePalindrome(self, s: str) -> bool:
        r = 0
        c = collections.Counter(s)
        for val in c.values():
            if val % 2 ==1:
                r += 1
        return r <=1

350. Intersection of Two Arrays II
https://leetcode.com/problems/intersection-of-two-arrays-ii/
#### dict based solution
##T:O(m+n), m=len(nums1),n=len(nums2)
##S:O(m)
def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        c = collections.Counter(nums1)
        res = []
        for num in nums2:
            if num in c:
                c[num] -= 1
                res.append(num)
                if c[num] ==0:
                    del c[num]
        return res
        
#### 2 pointers based solution if arrays are sorted
##T:O(m+n), m=len(nums1),n=len(nums2), if sort needed, then O(m+n+logm+logn)
##S:O(1)
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        i,j = 0, 0
        res = []
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                res.append(nums1[i])
                i += 1
                j += 1
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return res
        
1.What if the given array is already sorted? How would you optimize your algorithm?
If 2 arrays are sorted, definitely go with 2 pointers method, which will save space from m->1
2.What if nums1's size is small compared to nums2's size? Which algorithm is better?
if nums1's size is smaller, then go with either should be fine. Dict solution doesn't need sort, which is a plus.
3.What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
if can't load all, then we can do trunk by trunk. We need to sort the data first, then load trunk of them and compare. Or using HDFS to store the data.  

359. Logger Rate Limiter
https://leetcode.com/problems/logger-rate-limiter/
class Logger:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if message not in self.d:
            self.d[message] = timestamp
            return True
        else:
            if timestamp >= self.d[message]+10:
                self.d[message] = timestamp
                return True
            else:
                return False


347. Top K Frequent Elements
https://leetcode.com/problems/top-k-frequent-elements/
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        res = []
        d = collections.Counter(nums)        
        max_heap = [(-val, key) for key, val in d.items()]
        heapq.heapify(max_heap)
        for i in range(k):
            res.append(heapq.heappop(max_heap)[1])
        return res

409. Longest Palindrome
https://leetcode.com/problems/longest-palindrome/
class Solution:
    def longestPalindrome(self, s: str) -> int:
        c = set()
        for ch in s:
            if ch in c:
                c.remove(ch)
            else:
                c.add(ch)
        return len(s)-len(c)+1 if len(c)>0 else len(s)

463. Island Perimeter
https://leetcode.com/problems/island-perimeter/
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        self.res = 0
        self.m, self.n = len(grid), len(grid[0])
        visited = set()
        self.res = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == 1:
                    return self.dfs(grid, i, j, visited)
        return 0
                    
    def dfs(self, grid, i, j, visited):
        if (i,j) in visited:
            return 0
        if 0 <= i < self.m and 0 <= j < self.n and grid[i][j] == 1:
            visited.add((i,j))
            l = self.dfs(grid, i, j-1, visited)
            r = self.dfs(grid, i, j+1, visited)
            u = self.dfs(grid, i-1, j, visited)
            d = self.dfs(grid, i+1, j, visited)
            return l + r + u +d
        return 1

###########  set1 is subset of set2 if set1 <= set2 or just use issubset()  ###########
500. Keyboard Row
https://leetcode.com/problems/keyboard-row/
class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        line1, line2, line3 = set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')
        ret = []
        for word in words:
            w = set(word.lower())
            if w <= line1 or w <= line2 or w <= line3:
                ret.append(word)
        return ret

560. Subarray Sum Equals K
https://leetcode.com/problems/subarray-sum-equals-k/
class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        d = {0:1}
        su = 0
        res = 0
        for x in nums:
            su += x
            res += d.get(su-k,0)
            d[su] = d.get(su,0)+1
        return res

599. Minimum Index Sum of Two Lists
https://leetcode.com/problems/minimum-index-sum-of-two-lists/
class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        dic1, dic2 = {}, {}
        res_sum = len(list1)+len(list2)
        for i, s in enumerate(list1):
            dic1[s] = i
        for i, s in enumerate(list2):
            if s in dic1:
                tmp_sum = dic1[s] + i
                dic2[tmp_sum] = dic2.get(tmp_sum, []) + [s]
                res_sum = min(tmp_sum, res_sum)
        return dic2[res_sum]

645. Set Mismatch
https://leetcode.com/problems/set-mismatch/
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        d = collections.Counter(nums)
        for i in range(1,len(nums)+1):
            if d[i] == 2:
                twice = i
            if i not in d:
                never = i
        return twice,never
        

690. Employee Importance
https://leetcode.com/problems/employee-importance/
class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        emps = {employee.id: employee for employee in employees}
        def dfs(id):
            sub_imp = 0
            for sub in emps[id].subordinates:
                sub_imp += dfs(sub)
            return sub_imp + emps[id].importance
        return dfs(id)

692. Top K F
quent Wor
https://leetcode.com/problems/top-k-frequent-words/
class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        d = collections.Counter(words)
        max_heap = [(-val, key) for key, val in d.items()]
        heapq.heapify(max_heap)
        res = []
        while max_heap and k>0:
            res.append(heapq.heappop(max_heap)[1])
            k-=1
        return res

705. Design HashSet
https://leetcode.com/problems/design-hashset/
class MyHashSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.arr = [-1] * 100000

    def add(self, key: int) -> None:
        key = key % 100000
        self.arr[key] = 0
    def remove(self, key: int) -> None:
        key = key % 100000
        self.arr[key] = -1

    def contains(self, key: int) -> bool:
        """
        Returns true if this set contains the specified element
        """
        key = key % 100000
        return not self.arr[key] == -1


706. Design HashMap
https://leetcode.com/problems/design-hashmap/
class Node:
    def __init__(self, key=-1, val=-1, next=None):
        self.key = key
        self.val = val
        self.next = next

class MyHashMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = [Node() for _ in range(1000)]
    
    def hashcode(self,key):
        size = len(self.data)
        return key % size
    
    def put(self, key: int, value: int) -> None:
        """
        value will always be non-negative.
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                head.next.val = value
                return
            head = head.next
        head.next = Node(key,value)

    def get(self, key: int) -> int:
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                return head.next.val
            head = head.next
        return -1

    def remove(self, key: int) -> None:
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                tomove = head.next
                head.next = tomove.next
                tomove.next = None
                return
            head = head.next

#####################    learn how to use trie to sovle search word issue #####################
720. Longest Word in Dictionary
https://leetcode.com/problems/longest-word-in-dictionary/
https://leetcode.com/problems/longest-word-in-dictionary/discuss/203730/Python-Trie-%2B-DFS-(No-extensive-loops-or-complicated-TrieNode)
class TrieNode():
    def __init__(self):
        self.children = {}
        self.end = False
    
class Trie():
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.end = True
        
    def longest_word(self):
        def helper(node, partial_res):
            res = partial_res
            for c, child in node.children.items():
                if child.end:
                    po = helper(child, partial_res+c)
                    if len(po)>len(res):
                        res = po
                    elif len(po) == len(res) and po < res:
                        res = po
            return res
        return helper(self.root, '')

class Solution():
    def longestWord(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        t = Trie()
        for word in words:
            t.insert(word)
        return t.longest_word()

#####################    learn how to extract letter only by using isalpha() and counter can be subtracted by another counter #####################
748. Shortest Completing Word
https://leetcode.com/problems/shortest-completing-word/
class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        #d = Counter(x for x in licensePlate.lower() if x.isalpha())
        #return min([w for w in words if not d - Counter(w)], key = len)
        c = collections.Counter()
        res = []
        for x in licensePlate.lower():
            if x.isalpha():
                c[x] += 1
        for w in words:
            if not c-collections.Counter(w):
                res.append(w)
        return min(res,key=len)

771. Jewels and Stones
https://leetcode.com/problems/jewels-and-stones/
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        res = 0
        jew = set()
        for ch in jewels:
            jew.add(ch)
        for st in stones:
            if st in jew:
                res += 1
        return res

760. Find Anagram Mappings
https://leetcode.com/problems/find-anagram-mappings/
class Solution:
    def anagramMappings(self, A: List[int], B: List[int]) -> List[int]:
        d = {}
        for i,b in enumerate(B):
            d[b] = i
        return [d[a] for a in A]    
        

811. Subdomain Visit Count
https://leetcode.com/problems/subdomain-visit-count/
class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = {}
        for i in cpdomains:
            n, domains = i.split()
            n = int(n)
            domains = domains.split('.')
            for j in range(len(domains)):
                _str = '.'.join(domains[j:])
                d[_str] = d.get(_str,0) + n
        return [ str(d[i]) + ' ' + i for i in d ]

#####################    learn how to extract letter only by using re.findall(r'\w+',p) #####################
819. Most Common Word
https://leetcode.com/problems/most-common-word/
class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        d = {}
        ban = set(banned)
        words = re.findall(r'\w+', paragraph.lower())
        for word in words:
            if word not in ban:
                d[word] = d.get(word,0)+1
        m = max(d.values())
        for k,v in d.items():
            if v == m:
                return k

884. Uncommon Words from Two Sentences
https://leetcode.com/problems/uncommon-words-from-two-sentences/
class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        c = collections.Counter((A+' '+B).split(' '))
        return [k for k in c if c[k]==1]


953. Verifying an Alien Dictionary
https://leetcode.com/problems/verifying-an-alien-dictionary/
class Solution(object):
#T:O(n)
#S:O(n)

    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        dic = {}
        for i, w in enumerate(order):
            dic[w] = i

        words = [[dic[c] for c in w] for w in words]    
        for w1, w2 in zip(words, words[1:]):
            if w1 > w2:
                return False
        return True

961. N-Repeated Element in Size 2N Array
https://leetcode.com/problems/n-repeated-element-in-size-2n-array/
class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        d = {}
        for a in A:
            d[a] = d.get(a,0)+1
        for k,v in d.items():
            if v>1:
                return k

970. Powerful Integers
https://leetcode.com/problems/powerful-integers/
class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        res = set()
        stack = [(0,0)]
        while stack:
            i,j = stack.pop()
            temp = x**i+y**j
            if temp <= bound:
                res.add(temp)
                if x > 1:
                    stack.append((i+1,j))
                if y > 1:
                    stack.append((i,j+1))          
        return res

981. Time Based Key-Value Store
https://leetcode.com/problems/time-based-key-value-store/
class TimeMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.time = collections.defaultdict(list)
        self.value = collections.defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.time[key].append(timestamp)
        self.value[key].append(value)

    def get(self, key: str, timestamp: int) -> str:
        i = bisect.bisect(self.time[key], timestamp)
        return self.value[key][i-1] if i else ''

1002. Find Common Characters
https://leetcode.com/problems/find-common-characters/
class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        check = collections.Counter(A[0])
        for word in A[1:]:
            new_check = collections.Counter()
            for ch in word:
                if ch in check:
                    new_check[ch] += 1
                    check[ch] -= 1
                    if check[ch] == 0:
                        del check[ch]
            check = new_check
        res = []
        for key,val in check.items():
            for i in range(val):
                res.append(key)
        return res

1078. Occurrences After Bigram
https://leetcode.com/problems/occurrences-after-bigram/
class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        new = text.split(' ')
        res = []
        for i in range(2,len(new)):
            if new[i-2] == first and new[i-1] == second:
                res.append(new[i]) 
        return res

1086. High Five
https://leetcode.com/problems/high-five/
class Solution:
    def highFive(self, items: List[List[int]]) -> List[List[int]]:
        d = collections.defaultdict(list)
        for idx, val in items:
            heapq.heappush(d[idx],val)
            
            if len(d[idx])>5:
                heapq.heappop(d[idx])
                
        res = [[i,sum(d[i])//5] for i in sorted(d)]
        return res

1133. Largest Unique Number
https://leetcode.com/problems/largest-unique-number/
class Solution:
    def largestUniqueNumber(self, A: List[int]) -> int:
        d = {}
        res = -1
        for a in A:
            d[a] = d.get(a,0)+1
        for k,v in d.items():
            if v == 1:
                res = max(res,k)
        return res

1152. Analyze User Website Visit Pattern
https://leetcode.com/problems/analyze-user-website-visit-pattern/
from collections import defaultdict
from itertools import combinations
class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        packed_tuple = zip(timestamp,username,website)  #[(3,'james', 'home'),...]
        sorted_packed_tuple = sorted(packed_tuple)  #sort by first element of tuple
        
        mapping = defaultdict(list)
        for t, u, w in sorted_packed_tuple:
            mapping[u].append(w)  #websites in list are in ascending order
            
        counter_dict = defaultdict(int)  ##counter to check the number of different comb
        for website_list in mapping.values():
            combs = set(combinations(website_list,3))  ##generate combinations of websites
            for comb in combs:
                counter_dict[comb] += 1
        res = sorted(counter_dict, key = lambda x:(-counter_dict[x], x))  ##sort counter dict and sort by number in descending first, then lexicographically 
        return res[0]

1160. Find Words That Can Be Formed by Characters
https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        su, ct = 0, collections.Counter
        ch = ct(chars)
        for word in words:
            wr = ct(word)
            if all(wr[i] <= ch[i] for i in wr):
                su += len(word)
        return su
        
1189. Maximum Number of Balloons
https://leetcode.com/problems/maximum-number-of-balloons/
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        cnt = collections.Counter(text)
        cntBalloon = collections.Counter('balloon')
        res = []
        for c in cntBalloon:
            res.append(cnt[c]//cntBalloon[c])
        return min(res)

1207. Unique Number of Occurrences
https://leetcode.com/problems/unique-number-of-occurrences/class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = {}
        for ch in arr:
            d[ch] = d.get(ch,0)+1
        return len(d.values()) == len(set(d.values()))

1213. Intersection of Three Sorted Arrays
https://leetcode.com/problems/intersection-of-three-sorted-arrays/
class Solution:
    def arraysIntersection(self, arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]:
        d = {}
        res = []
        for a1 in arr1:
            d[a1] = d.get(a1,0)+1
        for a2 in arr2:
            d[a2] = d.get(a2,0)+1
        for a3 in arr3:
            d[a3] = d.get(a3,0)+1
        for k,v in d.items():
            if v == 3:
                res.append(k)
        return sorted(res)
        

1365. How Many Numbers Are Smaller Than the Current Number
https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        d = {}
        for i, num in enumerate(sorted(nums)):
            if num not in d:
                d[num] = i
        return [d[num] for num in nums]        

1512. Number of Good Pairs
https://leetcode.com/problems/number-of-good-pairs/
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        d = {}
        res = 0
        for v in nums:
            if v in d:
                if d[v] == 1:
                    res += 1
                else:
                    res += d[v]
                d[v] += 1
            else:
                d[v] = 1
        return res

1539. Kth Missing Positive Number
https://leetcode.com/problems/kth-missing-positive-number/
good solution:https://leetcode.com/problems/kth-missing-positive-number/discuss/1004535/Python-Two-solutions-O(n)-and-O(log-n)-explained
class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        s = set(arr)
        for i in range(1,len(s)+k+1):
            if i not in s:
                k -= 1
            if k == 0:
                return i
