96. Unique Binary Search Trees
https://leetcode.com/problems/unique-binary-search-trees/
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        cache = {}
        
        def counttree(n, cache):
            if n == 0:
                return 1     
            if n in cache:
                return cache[n]
            res = 0
            for i in range(n):
                left = counttree(i,cache)
                right = counttree(n-i-1,cache)
                res += left * right
            cache[n] = res    
            return res
        return counttree(n,cache)

95. Unique Binary Search Trees II
https://leetcode.com/problems/unique-binary-search-trees-ii/

class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        def buildtree(nums):
            if not nums:
                return [None]
            res = []
            for i in range(len(nums)):
                left_list = buildtree(nums[:i])
                right_list = buildtree(nums[i+1:])
                for left in left_list:
                    for right in right_list:
                        node = TreeNode(nums[i])
                        node.left = left
                        node.right = right
                        res+=[node]
            return res
        if n == 0:
            return []
        return buildtree([_ for _ in range(1,n+1)])


98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/

class Solution(object):
    def isValidBST(self, root, floor=float('-inf'), ceiling=float('inf')):
        if not root: 
            return True
        if root.val <= floor or root.val >= ceiling:
            return False
        # in the left branch, root is the new ceiling; contrarily root is the new floor in right branch
        return self.isValidBST(root.left, floor, root.val) and self.isValidBST(root.right, root.val, ceiling)

99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/
class Solution(object):
    def recoverTree(self, root): # O(n+lg(n)) space  
        res = []
        self.dfs(root, res)
        first, second = None, None
        for i in range(len(res)-1):
            if res[i].val > res[i+1].val and not first:
                first = res[i]
            if res[i].val > res[i+1].val and first:
                second = res[i+1]
        first.val, second.val = second.val, first.val
        
    def dfs(self, root, res):
        if root:
            self.dfs(root.left, res)
            res.append(root)
            self.dfs(root.right, res)

101. Symmetric Tree
https://leetcode.com/problems/symmetric-tree/

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.helper(root.left, root.right)
    def helper(self, node1, node2):
        if node1 and node2 and node1.val == node2.val:
            outer = self.helper(node1.left, node2.right)
            inner = self.helper(node1.right, node2.left)
            return outer and inner
        return node1 == node2

102. Binary Tree Level Order Traversal
#####  Iterative  ####
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp)
        return res

#####  Recurisve  ####
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res = []
        self.helper(root, 0, res)
        return res
    def helper(self, node, level, res):
        if not node:
            return
        if len(res) < level+1:
            res.append([])
        res[level].append(node.val)
        self.helper(node.left, level+1,res)
        self.helper(node.right, level+1,res)

103. Binary Tree Zigzag Level Order Traversal
https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

class Solution(object):
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        index = 1
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp[::index])
            index *= -1
        return res

104. Maximum Depth of Binary Tree
https://leetcode.com/problems/maximum-depth-of-binary-tree/
#####  Iterative  ####
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        i = 0
        q = collections.deque([root])
        while q:
            for j in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            i += 1
        return i
#####  Recursive  ####
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        return self.helper(root)
    def helper(self, node):
        if not node:
            return 0
        left = self.helper(node.left)
        right = self.helper(node.right)
        return max(left, right) + 1

105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if inorder:
            ind = inorder.index(preorder.pop(0))
            root = TreeNode(inorder[ind])
            root.left = self.buildTree(preorder,inorder[:ind])
            root.right = self.buildTree(preorder,inorder[ind+1:])
            return root

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        return self.build(preorder, 0,len(preorder)-1, inorder, 0, len(inorder)-1)
        
    def build(self, preorder, prestart, preend,
             inorder, instart, inend):
        if prestart>preend:
            return
        root_val = preorder[prestart]
        index = 0
        for i in range(instart,inend+1):
            if root_val == inorder[i]:
                index = i
                break
        left_len = index-instart
        root = TreeNode(root_val)
        root.left = self.build(preorder, prestart+1, prestart+left_len,inorder, instart, index-1)
        root.right = self.build(preorder, prestart+1+left_len, preend, inorder, index+1, inend)
        return root


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        return self.build(inorder, 0, len(inorder)-1, postorder, 0, len(postorder)-1)
    
    def build(self, inorder, instart, inend, postorder, poststart, postend):
        if instart > inend:
            return
        root_val = postorder[postend]
        index = -1
        for i in range(instart, inend+1):
            if inorder[i] == root_val:
                index = i
                break
        left_len = index - instart
        root = TreeNode(root_val)
        root.left = self.build(inorder, instart, index-1, postorder, poststart, poststart+left_len-1)
        root.right = self.build(inorder, index+1, inend, postorder, poststart+left_len, postend-1)
        return root

107. Binary Tree Level Order Traversal II
https://leetcode.com/problems/binary-tree-level-order-traversal-ii/

class Solution(object):
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp)
        return res[::-1]

108. Convert Sorted Array to Binary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
class Solution(object):
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        if not nums:
            return 
        return self.helper(nums,0,len(nums)-1)
    def helper(self, nums, left, right):
        if left > right:
            return
        mid = (left+right)/2
        root = TreeNode(nums[mid])
        root.left = self.helper(nums, left, mid-1)
        root.right = self.helper(nums, mid+1, right)
        return root

110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        return self.helper(root)!= -1

    def helper(self, node):
        if not node:
            return 0
        left = self.helper(node.left)
        if left == -1:
            return -1
        right = self.helper(node.right)
        if right == -1:
            return -1
        if abs(left-right)>1:
            return -1
        return max(left,right)+1
    
112. Path Sum
https://leetcode.com/problems/path-sum/
#####  Iterative  ####
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        q = collections.deque([(root,sum)])
        while q:
            node, val = q.popleft()
            if not node.left and not node.right and val == node.val:
                return True
            if node.left:
                q.append((node.left,val-node.val))
            if node.right:
                q.append((node.right, val-node.val))
        return False
            
#####  Recursive  ####
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        sum -= root.val
        if not root.left and not root.right and sum == 0:
            return True
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)

113. Path Sum II
https://leetcode.com/problems/path-sum-ii/
#####  Iterative  ####
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        if not root:
            return
        q, res = collections.deque([(root, sum, [])]), []
        while q:
            node,val,temp = q.popleft()
            if not node.left and not node.right and node.val == val:
                temp+=[node.val]
                res.append(temp)
            if node.left:
                q.append((node.left, val-node.val, temp+[node.val]))
            if node.right:
                q.append((node.right, val-node.val, temp+[node.val]))
        return res

#####  Recursive  ####
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res = []
        self.helper(root, sum, [], res)
        return res
    def helper(self, node, sum, ls, res):
        if node:
            if not node.left and not node.right and node.val == sum:
                ls.append(node.val)
                res.append(ls)
            self.helper(node.left, sum-node.val, ls+[node.val], res)
            self.helper(node.right, sum-node.val, ls+[node.val], res)

116. Populating Next Right Pointers in Each Node
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

class Solution(object):
#T:O(n)
#S:O(1)
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:
            return
        self.helper(root.left, root.right)
        return root
    def helper(self, node1, node2):
        if not node1 or not node2:
            return 
        node1.next = node2
        self.helper(node1.left,node1.right)
        self.helper(node2.left,node2.right)
        self.helper(node1.right,node2.left)

114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
class Solution(object):
#T:O(n)
#S:O(1)
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.left)
        self.flatten(root.right)
        left = root.left
        right = root.right
        root.left = None
        root.right = left
        p = root
        while p.right:
            p = p.right
        p.right = right
        return root

124. Binary Tree Maximum Path Sum
https://leetcode.com/problems/binary-tree-maximum-path-sum/
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_sum = float('-inf')
        self.dfs(root)
        return self.max_sum
    
    def dfs(self, node):
        if not node: return 0
        
        # only add positive contributions
        leftST_sum = max(0, self.dfs(node.left))
        rightST_sum = max(0, self.dfs(node.right))

        # check if cumulative sum at current node > global max sum so far
        # this evaluates a candidate path
        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)
        
        # add to the current node ONLY one of the children contributions
        # in order to maintain the constraint of considering only paths
        # if not, we would be exploring explore the whole tree - against problem definition
        return max(leftST_sum, rightST_sum) + node.val

129. Sum Root to Leaf Numbers
https://leetcode.com/problems/sum-root-to-leaf-numbers/
#####  Iterative  ####
class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return  0
        q = collections.deque([(root, 0)])
        res = 0
        while q:    
            node, ls = q.popleft()
            if not node.left and not node.right:
                ls = ls * 10 + node.val
                res += ls
            if node.left:
                q.append([node.left,ls*10+node.val])
            if node.right:
                q.append([node.right,ls*10+node.val])
        return res

#####  Recursive  ####
    def sumNumbers1(self, root): # DFS recursively 
            self.res = 0
            self.dfs(root, 0)
            return self.res

    def dfs(self, root, path):
        if root:
            if not root.left and not root.right:
                path = path*10 + root.val
                self.res += path
            self.dfs(root.left, path*10+root.val)
            self.dfs(root.right, path*10+root.val)
            
199. Binary Tree Right Side View
https://leetcode.com/problems/binary-tree-right-side-view/
#####  Iterative  ####
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        q = collections.deque([(root,[])])
        res = []
        while q:
            for _ in range(len(q)):
                node, path = q.popleft()
                path += [node.val]
                if node.left:
                    q.append((node.left, path))
                if node.right:
                    q.append((node.right, path))
            res.append(path[-1])
        return res

#####  Recursive  ####        
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root, 0)
        return self.res
    def helper(self, node, level):
        if node:
            if level == len(self.res):
                self.res.append(node.val)
            self.helper(node.right, level+1)
            self.helper(node.left, level+1)
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
class Solution(object):
#T:o(n)
#S:o(n)
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

class Solution(object):
#T:O(n)
#T:O(n)
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.rank = 0
        self.res = 0
        self.helper(root,k)
        return self.res
    def helper(self, root, k):
        if not root:
            return
        self.helper(root.left, k)
        self.rank += 1
        if self.rank == k:
            self.res = root.val
            return
        self.helper(root.right, k)


297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
#################################  preorder traverse  #################################
#################################  preorder traverse  #################################
class Codec:

    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        self.traverse(root, res)
        #print(','.join(res))
        return ','.join(res)
    
    def traverse(self, root, res):
        if not root:
            res.append('#')
            return
        res.append(str(root.val))
        self.traverse(root.left, res)
        self.traverse(root.right, res)
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        nodes = data.split(',')
        return self.dtraverse(nodes)
    
    def dtraverse(self, nodes):
        if not nodes:
            return
        first = nodes.pop(0)
        if first == '#':
            return
        root = TreeNode(int(first))
        root.left = self.dtraverse(nodes)
        root.right = self.dtraverse(nodes)
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
#################################  level order traverse  #################################
#################################  level order traverse  #################################
class Codec:
#T:O(n)
#S:O(n)
    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        res = []
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if node:
                q.append(node.left)
                q.append(node.right)
            res.append(str(node.val) if node else "#")
        return ','.join(res)
    
    
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        nodes = data.split(',')
        root = TreeNode(int(nodes[0]))
        q = collections.deque([root])
        i = 1
        while q:
            node = q.popleft()
            if nodes[i] is not "#":
                node.left = TreeNode(int(nodes[i]))
                q.append(node.left)
            i += 1
            if nodes[i] is not "#":
                node.right = TreeNode(int(nodes[i]))
                q.append(node.right)
            i += 1
        return root
# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))


450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/

class Solution(object):
#T:O(n)
#S:O(1)
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root:
            return 
        if root.val == key:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            min_node = self.getmin(root.right)
            root.val = min_node.val
            root.right = self.deleteNode(root.right, min_node.val)
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            root.left = self.deleteNode(root.left, key)
        return root
    def getmin(self, node):
        while node.left:
            node = node.left
        return node

538. Convert BST to Greater Tree
https://leetcode.com/problems/convert-bst-to-greater-tree/

class Solution(object):
#T:O(n)
#S:O(1)
    def convertBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.sum = 0
        self.helper(root)
        return root
    def helper(self, root):
        if not root:
            return
        self.helper(root.right)
        self.sum += root.val
        root.val = self.sum
        self.helper(root.left)


652. Find Duplicate Subtrees
https://leetcode.com/problems/find-duplicate-subtrees/
class Solution(object):
#T:O(n)
#S:O(n)
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        self.dic = {}
        self.res = []
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return '#'
        left = self.helper(root.left)
        right = self.helper(root.right)
        subtree = left + ','+right+','+ str(root.val)
        freq = self.dic.get(subtree,0)
        if freq == 1:
            self.res.append(root)
        self.dic[subtree] = self.dic.get(subtree,0) + 1
        return subtree



654. Maximum Binary Tree
https://leetcode.com/problems/maximum-binary-tree/
class Solution(object):
#T:O(nlogn)
#T:O(n)
    def constructMaximumBinaryTree(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        return self.build(nums,0,len(nums)-1)
        
    def build(self, nums, lo, hi):
        if lo > hi:
            return None
        index = -1
        max_val = float('-inf')
        for i in range(lo, hi+1):
            if nums[i] > max_val:
                index = i
                max_val = nums[i]
        new_root = TreeNode(max_val)
        new_root.left = self.build(nums, lo, index-1)
        new_root.right = self.build(nums, index+1, hi)
        return new_root
