98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/

class Solution(object):
    def isValidBST(self, root, floor=float('-inf'), ceiling=float('inf')):
        if not root: 
            return True
        if root.val <= floor or root.val >= ceiling:
            return False
        # in the left branch, root is the new ceiling; contrarily root is the new floor in right branch
        return self.isValidBST(root.left, floor, root.val) and self.isValidBST(root.right, root.val, ceiling)

99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/
class Solution(object):
    def recoverTree(self, root): # O(n+lg(n)) space  
        res = []
        self.dfs(root, res)
        first, second = None, None
        for i in range(len(res)-1):
            if res[i].val > res[i+1].val and not first:
                first = res[i]
            if res[i].val > res[i+1].val and first:
                second = res[i+1]
        first.val, second.val = second.val, first.val
        
    def dfs(self, root, res):
        if root:
            self.dfs(root.left, res)
            res.append(root)
            self.dfs(root.right, res)


105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if inorder:
            ind = inorder.index(preorder.pop(0))
            root = TreeNode(inorder[ind])
            root.left = self.buildTree(preorder,inorder[:ind])
            root.right = self.buildTree(preorder,inorder[ind+1:])
            return root

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        return self.build(preorder, 0,len(preorder)-1, inorder, 0, len(inorder)-1)
        
    def build(self, preorder, prestart, preend,
             inorder, instart, inend):
        if prestart>preend:
            return
        root_val = preorder[prestart]
        index = 0
        for i in range(instart,inend+1):
            if root_val == inorder[i]:
                index = i
                break
        left_len = index-instart
        root = TreeNode(root_val)
        root.left = self.build(preorder, prestart+1, prestart+left_len,inorder, instart, index-1)
        root.right = self.build(preorder, prestart+1+left_len, preend, inorder, index+1, inend)
        return root


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        return self.build(inorder, 0, len(inorder)-1, postorder, 0, len(postorder)-1)
    
    def build(self, inorder, instart, inend, postorder, poststart, postend):
        if instart > inend:
            return
        root_val = postorder[postend]
        index = -1
        for i in range(instart, inend+1):
            if inorder[i] == root_val:
                index = i
                break
        left_len = index - instart
        root = TreeNode(root_val)
        root.left = self.build(inorder, instart, index-1, postorder, poststart, poststart+left_len-1)
        root.right = self.build(inorder, index+1, inend, postorder, poststart+left_len, postend-1)
        return root


116. Populating Next Right Pointers in Each Node
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

class Solution(object):
#T:O(n)
#S:O(1)
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:
            return
        self.helper(root.left, root.right)
        return root
    def helper(self, node1, node2):
        if not node1 or not node2:
            return 
        node1.next = node2
        self.helper(node1.left,node1.right)
        self.helper(node2.left,node2.right)
        self.helper(node1.right,node2.left)

114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
class Solution(object):
#T:O(n)
#S:O(1)
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.left)
        self.flatten(root.right)
        left = root.left
        right = root.right
        root.left = None
        root.right = left
        p = root
        while p.right:
            p = p.right
        p.right = right
        return root

124. Binary Tree Maximum Path Sum
https://leetcode.com/problems/binary-tree-maximum-path-sum/
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_sum = float('-inf')
        self.dfs(root)
        return self.max_sum
    
    def dfs(self, node):
        if not node: return 0
        
        # only add positive contributions
        leftST_sum = max(0, self.dfs(node.left))
        rightST_sum = max(0, self.dfs(node.right))

        # check if cumulative sum at current node > global max sum so far
        # this evaluates a candidate path
        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)
        
        # add to the current node ONLY one of the children contributions
        # in order to maintain the constraint of considering only paths
        # if not, we would be exploring explore the whole tree - against problem definition
        return max(leftST_sum, rightST_sum) + node.val


226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
class Solution(object):
#T:o(n)
#S:o(n)
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

class Solution(object):
#T:O(n)
#T:O(n)
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.rank = 0
        self.res = 0
        self.helper(root,k)
        return self.res
    def helper(self, root, k):
        if not root:
            return
        self.helper(root.left, k)
        self.rank += 1
        if self.rank == k:
            self.res = root.val
            return
        self.helper(root.right, k)


297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
#################################  preorder traverse  #################################
#################################  preorder traverse  #################################
class Codec:

    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        self.traverse(root, res)
        #print(','.join(res))
        return ','.join(res)
    
    def traverse(self, root, res):
        if not root:
            res.append('#')
            return
        res.append(str(root.val))
        self.traverse(root.left, res)
        self.traverse(root.right, res)
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        nodes = data.split(',')
        return self.dtraverse(nodes)
    
    def dtraverse(self, nodes):
        if not nodes:
            return
        first = nodes.pop(0)
        if first == '#':
            return
        root = TreeNode(int(first))
        root.left = self.dtraverse(nodes)
        root.right = self.dtraverse(nodes)
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
#################################  level order traverse  #################################
#################################  level order traverse  #################################
class Codec:
#T:O(n)
#S:O(n)
    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        res = []
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if node:
                q.append(node.left)
                q.append(node.right)
            res.append(str(node.val) if node else "#")
        return ','.join(res)
    
    
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        nodes = data.split(',')
        root = TreeNode(int(nodes[0]))
        q = collections.deque([root])
        i = 1
        while q:
            node = q.popleft()
            if nodes[i] is not "#":
                node.left = TreeNode(int(nodes[i]))
                q.append(node.left)
            i += 1
            if nodes[i] is not "#":
                node.right = TreeNode(int(nodes[i]))
                q.append(node.right)
            i += 1
        return root
# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))


450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/

class Solution(object):
#T:O(n)
#S:O(1)
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root:
            return 
        if root.val == key:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            min_node = self.getmin(root.right)
            root.val = min_node.val
            root.right = self.deleteNode(root.right, min_node.val)
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            root.left = self.deleteNode(root.left, key)
        return root
    def getmin(self, node):
        while node.left:
            node = node.left
        return node

538. Convert BST to Greater Tree
https://leetcode.com/problems/convert-bst-to-greater-tree/

class Solution(object):
#T:O(n)
#S:O(1)
    def convertBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.sum = 0
        self.helper(root)
        return root
    def helper(self, root):
        if not root:
            return
        self.helper(root.right)
        self.sum += root.val
        root.val = self.sum
        self.helper(root.left)


652. Find Duplicate Subtrees
https://leetcode.com/problems/find-duplicate-subtrees/
class Solution(object):
#T:O(n)
#S:O(n)
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        self.dic = {}
        self.res = []
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return '#'
        left = self.helper(root.left)
        right = self.helper(root.right)
        subtree = left + ','+right+','+ str(root.val)
        freq = self.dic.get(subtree,0)
        if freq == 1:
            self.res.append(root)
        self.dic[subtree] = self.dic.get(subtree,0) + 1
        return subtree



654. Maximum Binary Tree
https://leetcode.com/problems/maximum-binary-tree/
class Solution(object):
#T:O(nlogn)
#T:O(n)
    def constructMaximumBinaryTree(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        return self.build(nums,0,len(nums)-1)
        
    def build(self, nums, lo, hi):
        if lo > hi:
            return None
        index = -1
        max_val = float('-inf')
        for i in range(lo, hi+1):
            if nums[i] > max_val:
                index = i
                max_val = nums[i]
        new_root = TreeNode(max_val)
        new_root.left = self.build(nums, lo, index-1)
        new_root.right = self.build(nums, index+1, hi)
        return new_root
