96. Unique Binary Search Trees
https://leetcode.com/problems/unique-binary-search-trees/
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        cache = {}
        
        def counttree(n, cache):
            if n == 0:
                return 1     
            if n in cache:
                return cache[n]
            res = 0
            for i in range(n):
                left = counttree(i,cache)
                right = counttree(n-i-1,cache)
                res += left * right
            cache[n] = res    
            return res
        return counttree(n,cache)

95. Unique Binary Search Trees II
https://leetcode.com/problems/unique-binary-search-trees-ii/

class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        def buildtree(nums):
            if not nums:
                return [None]
            res = []
            for i in range(len(nums)):
                left_list = buildtree(nums[:i])
                right_list = buildtree(nums[i+1:])
                for left in left_list:
                    for right in right_list:
                        node = TreeNode(nums[i])
                        node.left = left
                        node.right = right
                        res+=[node]
            return res
        if n == 0:
            return []
        return buildtree([_ for _ in range(1,n+1)])


98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/

class Solution(object):
    def isValidBST(self, root, floor=float('-inf'), ceiling=float('inf')):
        if not root: 
            return True
        if root.val <= floor or root.val >= ceiling:
            return False
        # in the left branch, root is the new ceiling; contrarily root is the new floor in right branch
        return self.isValidBST(root.left, floor, root.val) and self.isValidBST(root.right, root.val, ceiling)

99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/
class Solution(object):
    def recoverTree(self, root): # O(n+lg(n)) space  
        res = []
        self.dfs(root, res)
        first, second = None, None
        for i in range(len(res)-1):
            if res[i].val > res[i+1].val and not first:
                first = res[i]
            if res[i].val > res[i+1].val and first:
                second = res[i+1]
        first.val, second.val = second.val, first.val
        
    def dfs(self, root, res):
        if root:
            self.dfs(root.left, res)
            res.append(root)
            self.dfs(root.right, res)

101. Symmetric Tree
https://leetcode.com/problems/symmetric-tree/

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.helper(root.left, root.right)
    def helper(self, node1, node2):
        if node1 and node2 and node1.val == node2.val:
            outer = self.helper(node1.left, node2.right)
            inner = self.helper(node1.right, node2.left)
            return outer and inner
        return node1 == node2

102. Binary Tree Level Order Traversal
#####  Iterative  ####
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp)
        return res

#####  Recurisve  ####
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res = []
        self.helper(root, 0, res)
        return res
    def helper(self, node, level, res):
        if not node:
            return
        if len(res) < level+1:
            res.append([])
        res[level].append(node.val)
        self.helper(node.left, level+1,res)
        self.helper(node.right, level+1,res)

103. Binary Tree Zigzag Level Order Traversal
https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

class Solution(object):
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        index = 1
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp[::index])
            index *= -1
        return res

104. Maximum Depth of Binary Tree
https://leetcode.com/problems/maximum-depth-of-binary-tree/
#####  Iterative  ####
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        i = 0
        q = collections.deque([root])
        while q:
            for j in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            i += 1
        return i
#####  Recursive  ####
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        return self.helper(root)
    def helper(self, node):
        if not node:
            return 0
        left = self.helper(node.left)
        right = self.helper(node.right)
        return max(left, right) + 1

105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if inorder:
            ind = inorder.index(preorder.pop(0))
            root = TreeNode(inorder[ind])
            root.left = self.buildTree(preorder,inorder[:ind])
            root.right = self.buildTree(preorder,inorder[ind+1:])
            return root

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        return self.build(preorder, 0,len(preorder)-1, inorder, 0, len(inorder)-1)
        
    def build(self, preorder, prestart, preend,
             inorder, instart, inend):
        if prestart>preend:
            return
        root_val = preorder[prestart]
        index = 0
        for i in range(instart,inend+1):
            if root_val == inorder[i]:
                index = i
                break
        left_len = index-instart
        root = TreeNode(root_val)
        root.left = self.build(preorder, prestart+1, prestart+left_len,inorder, instart, index-1)
        root.right = self.build(preorder, prestart+1+left_len, preend, inorder, index+1, inend)
        return root


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        return self.build(inorder, 0, len(inorder)-1, postorder, 0, len(postorder)-1)
    
    def build(self, inorder, instart, inend, postorder, poststart, postend):
        if instart > inend:
            return
        root_val = postorder[postend]
        index = -1
        for i in range(instart, inend+1):
            if inorder[i] == root_val:
                index = i
                break
        left_len = index - instart
        root = TreeNode(root_val)
        root.left = self.build(inorder, instart, index-1, postorder, poststart, poststart+left_len-1)
        root.right = self.build(inorder, index+1, inend, postorder, poststart+left_len, postend-1)
        return root

107. Binary Tree Level Order Traversal II
https://leetcode.com/problems/binary-tree-level-order-traversal-ii/

class Solution(object):
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(temp)
        return res[::-1]

108. Convert Sorted Array to Binary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
class Solution(object):
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        if not nums:
            return 
        return self.helper(nums,0,len(nums)-1)
    def helper(self, nums, left, right):
        if left > right:
            return
        mid = (left+right)/2
        root = TreeNode(nums[mid])
        root.left = self.helper(nums, left, mid-1)
        root.right = self.helper(nums, mid+1, right)
        return root

110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        return self.helper(root)!= -1

    def helper(self, node):
        if not node:
            return 0
        left = self.helper(node.left)
        if left == -1:
            return -1
        right = self.helper(node.right)
        if right == -1:
            return -1
        if abs(left-right)>1:
            return -1
        return max(left,right)+1
    
112. Path Sum
https://leetcode.com/problems/path-sum/
#####  Iterative  ####
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        q = collections.deque([(root,sum)])
        while q:
            node, val = q.popleft()
            if not node.left and not node.right and val == node.val:
                return True
            if node.left:
                q.append((node.left,val-node.val))
            if node.right:
                q.append((node.right, val-node.val))
        return False
            
#####  Recursive  ####
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        sum -= root.val
        if not root.left and not root.right and sum == 0:
            return True
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)

113. Path Sum II
https://leetcode.com/problems/path-sum-ii/
#####  Iterative  ####
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        if not root:
            return
        q, res = collections.deque([(root, sum, [])]), []
        while q:
            node,val,temp = q.popleft()
            if not node.left and not node.right and node.val == val:
                temp+=[node.val]
                res.append(temp)
            if node.left:
                q.append((node.left, val-node.val, temp+[node.val]))
            if node.right:
                q.append((node.right, val-node.val, temp+[node.val]))
        return res

#####  Recursive  ####
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res = []
        self.helper(root, sum, [], res)
        return res
    def helper(self, node, sum, ls, res):
        if node:
            if not node.left and not node.right and node.val == sum:
                ls.append(node.val)
                res.append(ls)
            self.helper(node.left, sum-node.val, ls+[node.val], res)
            self.helper(node.right, sum-node.val, ls+[node.val], res)

116. Populating Next Right Pointers in Each Node
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

class Solution(object):
#T:O(n)
#S:O(1)
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:
            return
        self.helper(root.left, root.right)
        return root
    def helper(self, node1, node2):
        if not node1 or not node2:
            return 
        node1.next = node2
        self.helper(node1.left,node1.right)
        self.helper(node2.left,node2.right)
        self.helper(node1.right,node2.left)

114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
class Solution(object):
#T:O(n)
#S:O(1)
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.left)
        self.flatten(root.right)
        left = root.left
        right = root.right
        root.left = None
        root.right = left
        p = root
        while p.right:
            p = p.right
        p.right = right
        return root

124. Binary Tree Maximum Path Sum
https://leetcode.com/problems/binary-tree-maximum-path-sum/
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_sum = float('-inf')
        self.dfs(root)
        return self.max_sum
    
    def dfs(self, node):
        if not node: return 0
        
        # only add positive contributions
        leftST_sum = max(0, self.dfs(node.left))
        rightST_sum = max(0, self.dfs(node.right))

        # check if cumulative sum at current node > global max sum so far
        # this evaluates a candidate path
        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)
        
        # add to the current node ONLY one of the children contributions
        # in order to maintain the constraint of considering only paths
        # if not, we would be exploring explore the whole tree - against problem definition
        return max(leftST_sum, rightST_sum) + node.val

129. Sum Root to Leaf Numbers
https://leetcode.com/problems/sum-root-to-leaf-numbers/
#####  Iterative  ####
class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return  0
        q = collections.deque([(root, 0)])
        res = 0
        while q:    
            node, ls = q.popleft()
            if not node.left and not node.right:
                ls = ls * 10 + node.val
                res += ls
            if node.left:
                q.append([node.left,ls*10+node.val])
            if node.right:
                q.append([node.right,ls*10+node.val])
        return res

#####  Recursive  ####
    def sumNumbers1(self, root): # DFS recursively 
            self.res = 0
            self.dfs(root, 0)
            return self.res

    def dfs(self, root, path):
        if root:
            if not root.left and not root.right:
                path = path*10 + root.val
                self.res += path
            self.dfs(root.left, path*10+root.val)
            self.dfs(root.right, path*10+root.val)
            
199. Binary Tree Right Side View
https://leetcode.com/problems/binary-tree-right-side-view/
#####  Iterative  ####
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        q = collections.deque([(root,[])])
        res = []
        while q:
            for _ in range(len(q)):
                node, path = q.popleft()
                path += [node.val]
                if node.left:
                    q.append((node.left, path))
                if node.right:
                    q.append((node.right, path))
            res.append(path[-1])
        return res

#####  Recursive  ####        
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root, 0)
        return self.res
    def helper(self, node, level):
        if node:
            if level == len(self.res):
                self.res.append(node.val)
            self.helper(node.right, level+1)
            self.helper(node.left, level+1)
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
class Solution(object):
#T:o(n)
#S:o(n)
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

class Solution(object):
#T:O(n)
#T:O(n)
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.rank = 0
        self.res = 0
        self.helper(root,k)
        return self.res
    def helper(self, root, k):
        if not root:
            return
        self.helper(root.left, k)
        self.rank += 1
        if self.rank == k:
            self.res = root.val
            return
        self.helper(root.right, k)

235. Lowest Common Ancestor of a Binary Search Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

class Solution(object):
#T:O(logn)
#S:O(logn)
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        while root:
            if max(p.val, q.val) < root.val:
                root = root.left
            elif min(p.val, q.val) > root.val:
                root = root.right
            else:
                return root
        return None
    

236. Lowest Common Ancestor of a Binary Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

class Solution(object):
#T:O(n)
#S:O(n)
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if root:
            if root==p or root==q:
                return root
            left = self.lowestCommonAncestor(root.left, p, q)
            right = self.lowestCommonAncestor(root.right, p, q)
            if left and right:
                return root
            if left or right:
                return left or right

1644. Lowest Common Ancestor of a Binary Tree II
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/
class Solution(object):
#T:O(n)
#S:O(n)
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        self.res = None
        self.helper(root, p, q)
        return self.res
    def helper(self, node, p,q):
        if node:
            left = self.helper(node.left, p,q)
            right = self.helper(node.right, p,q)
            # if both find, then current node is LCA
            if left and right:
                self.res = node
                return False
            # if either branch find and the other node exists, then current node is LCA
            elif (left or right) and (node == p or node == q):
                self.res = node
                return False
            #check whether p or q is in the tree
            elif node == p or node == q:
                return True
            # for everything else, return left or right if either finds something, otherwise false
            else:
                return left or right

250. Count Univalue Subtrees
https://leetcode.com/problems/count-univalue-subtrees/

lass Solution(object):
    def countUnivalSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.res = 0
        self.helper(root,0)
        return self.res
    def helper(self, node, parent):
        if node:
            left = self.helper(node.left, node.val)
            right = self.helper(node.right, node.val)
            if left and right:
                self.res += 1
            return left and right and node.val == parent
        return True

257. Binary Tree Paths
https://leetcode.com/problems/binary-tree-paths/
#####  Iterative  ####
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if not root:
            return []
        q = collections.deque([(root,[])])
        res = []
        while q:
            node, path = q.popleft()
            if not node.left and not node.right:
                path.append(node.val)
                res.append('->'.join([str(i) for i in path])) 
            if node.left:
                q.append((node.left, path+[node.val]))
            if node.right:
                q.append((node.right, path+[node.val]))
        return res
#####  Recursive  #### 
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if not root:
            return []
        self.res = []
        self.helper(root,[])
        return self.res
    def helper(self, node, path):
        if not node:
            return
        if not node.left and not node.right:
            path += [node.val]
            self.res.append('->'.join([str(i) for i in path]))
        self.helper(node.left, path + [node.val])
        self.helper(node.right, path + [node.val])

270. Closest Binary Search Tree Value
https://leetcode.com/problems/closest-binary-search-tree-value/
class Solution(object):
    def closestValue(self, root, target):
        """
        :type root: TreeNode
        :type target: float
        :rtype: int
        """
        self.res = 0
        self.min = float('inf')
        self.helper(root, target)
        return self.res
    
    def helper(self, node, target):
        if node:
            if abs(node.val - target) < self.min:
                self.min = abs(node.val - target) 
                self.res = node.val
            if target < node.val:
                self.helper(node.left, target)
            else:
                self.helper(node.right, target)

272. Closest Binary Search Tree Value II
https://leetcode.com/problems/closest-binary-search-tree-value-ii/
class Solution(object):
#T:O(k+logn)
#S:O(n)
    def closestKValues(self, root, target, k):
        """
        :type root: TreeNode
        :type target: float
        :type k: int
        :rtype: List[int]
        """
        res = []
        prestack = []
        succstack = []
        while root:
            if root.val < target:
                prestack.append(root)
                root = root.right
            else:
                succstack.append(root)
                root = root.left
        
        def getpre(stack):
            if stack:
                pre = stack.pop()
                p = pre.left
                while p:
                    stack.append(p)
                    p = p.right
                return pre
        def getsuc(stack):
            if stack:
                suc = stack.pop()
                p = suc.right
                while p:
                    stack.append(p)
                    p = p.left
                return suc
        pre = getpre(prestack)
        suc = getsuc(succstack)
        
        while k:
            k -= 1
            if pre and not suc:
                res.append(pre.val)
                pre = getpre(prestack)
            elif suc and not pre:
                res.append(suc.val)
                suc = getsuc(succstack)
            elif suc and pre and abs(pre.val - target) <= abs(suc.val-target):
                res.append(pre.val)
                pre = getpre(prestack)
            elif suc and pre and abs(pre.val - target) >= abs(suc.val-target):
                res.append(suc.val)
                suc = getsuc(succstack)
        return res

285. Inorder Successor in BST
https://leetcode.com/problems/inorder-successor-in-bst/

###### Recursive #######
class Solution(object):
    def inorderSuccessor(self, root, p):
        """
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        """
        if root:
            if root.val > p.val:
                return self.inorderSuccessor(root.left, p) or root 
            else:
                return self.inorderSuccessor(root.right,p)
                
###### Iterative #######                
class Solution(object):
    def inorderSuccessor(self, root, p):
        """
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        """
        succ = None
        while root:
            if root.val > p.val:
                succ = root
                root = root.left
            else:
                root = root.right
        return succ

297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
#################################  preorder traverse  #################################
#################################  preorder traverse  #################################
class Codec:

    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        self.traverse(root, res)
        #print(','.join(res))
        return ','.join(res)
    
    def traverse(self, root, res):
        if not root:
            res.append('#')
            return
        res.append(str(root.val))
        self.traverse(root.left, res)
        self.traverse(root.right, res)
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        nodes = data.split(',')
        return self.dtraverse(nodes)
    
    def dtraverse(self, nodes):
        if not nodes:
            return
        first = nodes.pop(0)
        if first == '#':
            return
        root = TreeNode(int(first))
        root.left = self.dtraverse(nodes)
        root.right = self.dtraverse(nodes)
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
#################################  level order traverse  #################################
#################################  level order traverse  #################################
class Codec:
#T:O(n)
#S:O(n)
    def serialize(self, root):
        #T:O(n)
        #S:O(n)
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        res = []
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if node:
                q.append(node.left)
                q.append(node.right)
            res.append(str(node.val) if node else "#")
        return ','.join(res)
    
    
    def deserialize(self, data):
        #T:O(n2)
        #S:O(n)
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        nodes = data.split(',')
        root = TreeNode(int(nodes[0]))
        q = collections.deque([root])
        i = 1
        while q:
            node = q.popleft()
            if nodes[i] is not "#":
                node.left = TreeNode(int(nodes[i]))
                q.append(node.left)
            i += 1
            if nodes[i] is not "#":
                node.right = TreeNode(int(nodes[i]))
                q.append(node.right)
            i += 1
        return root
# Your Codec object will be instantiated and called as such:
# ser = Codec()

# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

298. Binary Tree Longest Consecutive Sequence
https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/

class Solution(object):
#T:O(n)
#S:O(n)
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.res = 0
        self.helper(root,0,root.val)
        return self.res
    def helper(self, node,cnt, target):
        if node:
            if node.val == target:
                cnt += 1
            else:
                target = node.val 
                cnt = 1
            self.res = max(self.res, cnt)
            self.helper(node.left, cnt, target+1)
            self.helper(node.right, cnt, target+1)

333. Largest BST Subtree
https://leetcode.com/problems/largest-bst-subtree/
class Solution(object):
    def largestBSTSubtree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if self.verifyBST(root, float('-inf'), float('inf')):
            return self.getcount(root)
        return max(self.largestBSTSubtree(root.left),self.largestBSTSubtree(root.right))
    
          
    def verifyBST(self, node, lo, hi):
        if not node:
            return True
        if node.val <= lo or node.val >= hi:
            return False
        left = self.verifyBST(node.left, lo, node.val)
        right = self.verifyBST(node.right, node.val, hi)
        return left and right
    
    def getcount(self, node):
        if not node:
            return 0
        left = self.getcount(node.left)
        right = self.getcount(node.right)
        return left+ right + 1

366. Find Leaves of Binary Tree
https://leetcode.com/problems/find-leaves-of-binary-tree/
class Solution(object):
    def findLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.dic =collections.defaultdict(list)
        self.helper(root)
        return list(self.dic.values())
        
    def helper(self, node):
        if node: 
            left = self.helper(node.left)
            right = self.helper(node.right)
            level = max(left, right) + 1
            self.dic[level].append(node.val)
            return level
        return 0

404. Sum of Left Leaves
https://leetcode.com/problems/sum-of-left-leaves/
class Solution(object):
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.res = 0
        self.helper(root)
        return self.res
        
    def helper(self, node):
        if node:
            if node.left and not node.left.left and not node.left.right:
                self.res += node.left.val
            self.helper(node.left)
            self.helper(node.right)

429. N-ary Tree Level Order Traversal
https://leetcode.com/problems/n-ary-tree-level-order-traversal/
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: Node
        :rtype: List[List[int]]
        """
        if not root:
            return root
        q = collections.deque([(root,0)])
        res = []
        while q:
            node, level = q.popleft()
            if len(res) < level + 1:
                res.append([])
            for child in node.children:
                q.append((child,level+1))
            res[level].append(node.val)
        return res

437. Path Sum III
https://leetcode.com/problems/path-sum-iii/
https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-)
class Solution(object):
#T:O(nlogn) to O(n^2)
#S:O(n)
############### brute force  ###############
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """
        self.numpath = 0
        self.dfs(root, sum)
        return self.numpath
    
    def dfs(self, node, sum):
        if node:
            self.test(node, sum)
            self.dfs(node.left, sum)
            self.dfs(node.right, sum)
    def test(self, node, sum):
        if node:
            if node.val == sum:
                self.numpath += 1
            self.test(node.left, sum - node.val)
            self.test(node.right, sum - node.val)

############### memo  ###############
class Solution(object):
#T:O(n)
#S:O(n)
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """
        self.res = 0
        dic = {0:1}
        self.helper(root, sum, 0, dic)
        return self.res
    
    def helper(self, node, sum, curentpathsum, dic):
        if node:
            curentpathsum += node.val
            oldpathsum = curentpathsum - sum
            self.res += dic.get(oldpathsum,0)
            dic[curentpathsum] = dic.get(curentpathsum,0)+1
            
            self.helper(node.left, sum, curentpathsum, dic)
            self.helper(node.right, sum, curentpathsum, dic)
            dic[curentpathsum] -= 1
            
450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/

class Solution(object):
#T:O(n)
#S:O(1)
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root:
            return 
        if root.val == key:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            min_node = self.getmin(root.right)
            root.val = min_node.val
            root.right = self.deleteNode(root.right, min_node.val)
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            root.left = self.deleteNode(root.left, key)
        return root
    def getmin(self, node):
        while node.left:
            node = node.left
        return node

501. Find Mode in Binary Search Tree
https://leetcode.com/problems/find-mode-in-binary-search-tree/
#T:O(n)
#S:O(n)
class Solution(object):
    def findMode(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        self.dic={}
        self.helper(root)
        m = float('-inf')
        for key in self.dic:
            if self.dic[key]>m:
                m = self.dic[key]
        res = []
        for key,val in self.dic.items():
            if val == m:
                res.append(key)
        return res
    def helper(self, node):
        if node:
            self.dic[node.val] = self.dic.get(node.val,0)+1
            self.helper(node.left)
            self.helper(node.right)
class Solution(object):
#T:O(n)
#S:O(1)
    def findMode(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        self.prev = None
        self.curr_count = 0
        self.max_count = 0
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            self.helper(node.left)
            if node.val == self.prev:
                self.curr_count += 1
            else:
                self.curr_count = 1
            if self.curr_count > self.max_count:
                self.max_count = self.curr_count
                self.res = [node.val]
            elif self.curr_count == self.max_count:
                self.res.append(node.val)
            self.prev = node.val
            self.helper(node.right)

508. Most Frequent Subtree Sum
https://leetcode.com/problems/most-frequent-subtree-sum/
class Solution(object):
    def findFrequentTreeSum(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root is None: return []

        self.count = collections.Counter()
        self.dfs(root)
        maxCount = max(self.count.values())
        return [s for s in self.count if self.count[s] == maxCount]
    def dfs(self, node):
            if node is None: return 0
            s = node.val + self.dfs(node.left) + self.dfs(node.right)
            self.count[s] += 1
            return s

513. Find Bottom Left Tree Value
https://leetcode.com/problems/find-bottom-left-tree-value/
class Solution(object):
    def findBottomLeftValue(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        q = collections.deque([(root,1)])
        max_depth = 0
        ans = 0
        while q:
            node, level = q.popleft()
            if node:
                if level > max_depth:
                    max_depth = level
                    ans = node.val
                q.append((node.left, level+1))
                q.append((node.right, level+1))
        return ans

515. Find Largest Value in Each Tree Row
https://leetcode.com/problems/find-largest-value-in-each-tree-row/
class Solution(object):
    def largestValues(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        q = collections.deque([root])
        res = []
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft() 
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                temp.append(node.val)
            res.append(max(temp))
        return res


530. Minimum Absolute Difference in BST
https://leetcode.com/problems/minimum-absolute-difference-in-bst/
class Solution(object):
    def getMinimumDifference(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.min = self.pre = float('inf')
        self.helper(root)
        return self.min
    
    def helper(self, node):
        if node:
            self.helper(node.left)
            self.min = min(self.min, abs(node.val-self.pre))
            self.pre = node.val
            self.helper(node.right)
            
536. Construct Binary Tree from String
https://leetcode.com/problems/construct-binary-tree-from-string/

class Solution(object):
    def str2tree(self, s):
        """
        :type s: str
        :rtype: TreeNode
        """
        if not s or len(s) ==0:
            return None
        node, i = self.helper(s, 0)
        return node
        
    def helper(self, s, i):
        start = i
        while i < len(s) and (s[i] == '-' or s[i].isdigit()):
            i += 1
        node = TreeNode(int(s[start:i]))
        if i < len(s) and s[i] == '(':
            i += 1
            node.left, i = self.helper(s,i)
            i += 1
        if i < len(s) and s[i] == '(':
            i += 1
            node.right, i = self.helper(s,i)
            i += 1
        return node, i

538. Convert BST to Greater Tree
https://leetcode.com/problems/convert-bst-to-greater-tree/

class Solution(object):
#T:O(n)
#S:O(1)
    def convertBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.sum = 0
        self.helper(root)
        return root
    def helper(self, root):
        if not root:
            return
        self.helper(root.right)
        self.sum += root.val
        root.val = self.sum
        self.helper(root.left)

543. Diameter of Binary Tree
https://leetcode.com/problems/diameter-of-binary-tree/
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.ans = 0
        self.helper(root)
        return self.ans
    
    def helper(self, node):
        if node:
            left, right = self.helper(node.left),self.helper(node.right)
            self.ans = max(self.ans, left+right)
            return max(left, right)+1
        return 0

545. Boundary of Binary Tree
https://leetcode.com/problems/boundary-of-binary-tree/
class Solution(object):
#T:O(n)
#S:O(n)
    def boundaryOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """

        def leftmost(node):
            if not node or not node.left and not node.right:
                return
            res.append(node.val)
            if node.left:
                leftmost(node.left)
            else:
                leftmost(node.right)
        def leaf(node):
            if not node:
                return
            leaf(node.left)
            if node != root and not node.left and not node.right:
                res.append(node.val)
            leaf(node.right)
        def rightmost(node):
            if not node or not node.left and not node.right:
                return 
            if node.right:
                rightmost(node.right)
            else:
                rightmost(node.left)
            res.append(node.val)
        if not root:
            return []
        res = [root.val]
        leftmost(root.left)
        leaf(root)
        rightmost(root.right)
        return res

559. Maximum Depth of N-ary Tree
https://leetcode.com/problems/maximum-depth-of-n-ary-tree/
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: Node
        :rtype: int
        """
        if not root:
            return 0
        height = 0
        for child in root.children:
            height = max(height, self.maxDepth(child))
        return height+1        

563. Binary Tree Tilt
https://leetcode.com/problems/binary-tree-tilt/
class Solution(object):
    def findTilt(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        self.helper(root)
        return self.res
        
    def helper(self, node):
        if node:
            left = self.helper(node.left)
            right = self.helper(node.right)
            self.res += abs(left - right)
            return node.val + left + right
        return 0


572. Subtree of Another Tree
https://leetcode.com/problems/subtree-of-another-tree/
class Solution(object):
    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s:
            return False
        if self.helper(s,t):
            return True
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
        
        
    def helper(self, p, q):
        if p and q:
            return p.val == q.val and self.helper(p.left, q.left) and self.helper(p.right, q.right)
        return p is q

582. Kill Process
https://leetcode.com/problems/kill-process/
############  Iterative  ############  
class Solution(object):
    def killProcess(self, pid, ppid, kill):
        """
        :type pid: List[int]
        :type ppid: List[int]
        :type kill: int
        :rtype: List[int]
        """
        parent, q = collections.defaultdict(list), collections.deque([kill])
        for kid, par in zip(pid, ppid):
            parent[par].append(kid)
        res = []        
        while q:
            for _ in range(len(q)):
                x = q.popleft()
                res.append(x)
                if x in parent:
                    q.extend(parent[x])
        return res
     
589. N-ary Tree Preorder Traversal
https://leetcode.com/problems/n-ary-tree-preorder-traversal/
class Solution(object):
    def preorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            self.res.append(node.val)
            for child in node.children:
                self.helper(child)
        
590. N-ary Tree Postorder Traversal
https://leetcode.com/problems/n-ary-tree-postorder-traversal/
class Solution(object):
    def postorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        self.res = []
        self.helper(root)
        return self.res
    def helper(self, node):
        if node:
            for child in node.children:
                self.helper(child)
            self.res.append(node.val)
            

606. Construct String from Binary Tree
https://leetcode.com/problems/add-one-row-to-tree/

class Solution(object):
    def tree2str(self, t):
        """
        :type t: TreeNode
        :rtype: str
        """
        if not t:
            return ""
        res = ""
        left = self.tree2str(t.left)
        right = self.tree2str(t.right)
        if left or right:
            res += "(%s)" %left
        if right:
            res += "(%s)" %right
        return str(t.val)+res 
        
617. Merge Two Binary Trees
https://leetcode.com/problems/merge-two-binary-trees/
############  Recursive  ############
class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if t1 and t2:
            root = TreeNode(t1.val+t2.val)
            root.left = self.mergeTrees(t1.left, t2.left)
            root.right = self.mergeTrees(t1.right, t2.right)
            return root
        else:
            return t1 or t2
            
############  Iterative  ############  
class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if not t1 or not t2:
            return t1 or t2
        q1, q2 = collections.deque([t1]),collections.deque([t2])
        while q1 and q2:
            node1, node2 = q1.popleft(), q2.popleft()
            if node1 and node2:
                node1.val = node1.val + node2.val
                if (not node1.left) and node2.left:
                    node1.left = TreeNode(0)
                if (not node1.right) and node2.right:
                    node1.right = TreeNode(0)
                q1.append(node1.left)
                q1.append(node1.right)
                q2.append(node2.left)
                q2.append(node2.right)
        return t1
        
623. Add One Row to Tree
https://leetcode.com/problems/add-one-row-to-tree/
class Solution(object):
    def addOneRow(self, root, v, d):
        """
        :type root: TreeNode
        :type v: int
        :type d: int
        :rtype: TreeNode
        """
        if not root:
            return
        if d == 1:
            new_root = TreeNode(v)
            new_root.left = root
            return new_root
        q = collections.deque([root])
        i = 1
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                if i == d-1:
                    o_l = node.left
                    o_r = node.right
                    node.left = TreeNode(v)
                    node.right = TreeNode(v)
                    node.left.left = o_l
                    node.right.right = o_r
            i += 1
        return root


637. Average of Levels in Binary Tree
https://leetcode.com/problems/average-of-levels-in-binary-tree/
class Solution(object):
    def averageOfLevels(self, root):
        """
        :type root: TreeNode
        :rtype: List[float]
        """
        if not root:
            return []
        res = []
        q = collections.deque([root])
        while q:
            temp = []
            for _ in range(len(q)):
                node = q.popleft()
                temp.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(sum(temp)/float(len(temp)))
        return res

652. Find Duplicate Subtrees
https://leetcode.com/problems/find-duplicate-subtrees/
class Solution(object):
#T:O(n)
#S:O(n)
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        self.dic = {}
        self.res = []
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return '#'
        left = self.helper(root.left)
        right = self.helper(root.right)
        subtree = left + ','+right+','+ str(root.val)
        freq = self.dic.get(subtree,0)
        if freq == 1:
            self.res.append(root)
        self.dic[subtree] = self.dic.get(subtree,0) + 1
        return subtree



654. Maximum Binary Tree
https://leetcode.com/problems/maximum-binary-tree/
class Solution(object):
#T:O(nlogn)
#T:O(n)
    def constructMaximumBinaryTree(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        return self.build(nums,0,len(nums)-1)
        
    def build(self, nums, lo, hi):
        if lo > hi:
            return None
        index = -1
        max_val = float('-inf')
        for i in range(lo, hi+1):
            if nums[i] > max_val:
                index = i
                max_val = nums[i]
        new_root = TreeNode(max_val)
        new_root.left = self.build(nums, lo, index-1)
        new_root.right = self.build(nums, index+1, hi)
        return new_root

655. Print Binary Tree
https://leetcode.com/problems/print-binary-tree/
class Solution(object):
    def printTree(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[str]]
        """
        if not root:
            return
        height = self.getheight(root)
        width = 2 ** height - 1
        self.matrix = [["" for _ in range(width)] for _ in range(height)]
        self.update(root, 0, 0, width-1)
        return self.matrix
        
    def getheight(self, node):
        if not node:
            return 0
        return 1 + max(self.getheight(node.left),self.getheight(node.right))
    def update(self, node, row, left, right):
        if not node:
            return
        mid = (left+right)/2
        self.matrix[row][mid] = str(node.val)
        self.update(node.left, row+1, left, mid-1)
        self.update(node.right, row+1, mid+1, right)

662. Maximum Width of Binary Tree
https://leetcode.com/problems/maximum-width-of-binary-tree/

class Solution(object):
    def widthOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return
        q = collections.deque([(root, 0, 0)])
        cur_level = 0
        left = 0
        max_width = 0
        
        while q:
            for _ in range(len(q)):
                node, level, pos = q.popleft()
                if node:
                    q.append((node.left, level+1, pos*2))
                    q.append((node.right, level+1, pos*2+1))
                    if level != cur_level:
                        cur_level = level
                        left = pos
                    max_width = max(pos-left+1, max_width)
            
        return max_width

663. Equal Tree Partition
https://leetcode.com/problems/equal-tree-partition/
class Solution:
    def checkEqualTree(self, root: TreeNode) -> bool:
        self.root = root
        self.cuts = set()
        su = self.getsum(self.root)
        return su/2 in self.cuts
    def getsum(self, node: TreeNode)->int:
        if node:
            s = node.val + self.getsum(node.left) + self.getsum(node.right)
            if node is not self.root:
                self.cuts.add(s)
            return s
        return 0


666. Path Sum IV
https://leetcode.com/problems/path-sum-iv/
class Solution(object):
#T:O(n)
#S:O(n)
    def pathSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = collections.defaultdict(int)
        for num in nums:
            level, pos, val = num / 100, (num /10)%10, num%10
            dic[level, pos] = dic[level-1,(pos+1)/2] + val
        
        res = 0
        for level, pos in dic.keys():
            if (level+1, pos * 2) not in dic.keys() and (level+1, pos * 2-1) not in dic.keys():
                res += dic[level, pos]
        return res

669. Trim a Binary Search Tree
https://leetcode.com/problems/trim-a-binary-search-tree/
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        if not root:
            return
        if root.val > high:
            return self.trimBST(root.left, low, high)
        if root.val < low:
            return self.trimBST(root.right, low, high)
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        return root

671. Second Minimum Node In a Binary Tree
https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        self.second = float('inf')
        self.root = root
        self.helper(self.root)
        return self.second if self.second != float('inf') else -1
        
    def helper(self, node: TreeNode) -> int:
        if node:
            if self.root.val < node.val < self.second:
                self.second = node.val
            if self.root.val == node.val:
                self.helper(node.left)
                self.helper(node.right)

687. Longest Univalue Path
https://leetcode.com/problems/longest-univalue-path/
class Solution(object):
    def longestUnivaluePath(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.max= 0
        self.helper(root, None)
        return self.max
    
    def helper(self, node, parent):
        if node:
            left = self.helper(node.left, node.val)  
            right = self.helper(node.right, node.val)
            self.max = max(self.max, left+right)
            if node.val == parent:
                return max(left, right)+1
            else:
                return 0
        return 0

742. Closest Leaf in a Binary Tree
https://leetcode.com/problems/closest-leaf-in-a-binary-tree/
class Solution(object):
    def findClosestLeaf(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.dic = collections.defaultdict(list)
        self.s = set()
        self.traverse(root)
        q = collections.deque([k])
        seen = set()
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                if node in seen:
                    continue
                if node in self.s:
                    return node
                seen.add(node)
                q.extend(self.dic[node])
                
    def traverse(self, node):
        if not node:
            return
        if not node.left and not node.right:
            self.s.add(node.val)
            return
        if node.left:
            self.dic[node.val].append(node.left.val)
            self.dic[node.left.val].append(node.val)
            self.traverse(node.left)
        if node.right:
            self.dic[node.val].append(node.right.val)
            self.dic[node.right.val].append(node.val)
            self.traverse(node.right)
            
