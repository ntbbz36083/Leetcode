99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/
class Solution(object):
    def recoverTree(self, root): # O(n+lg(n)) space  
        res = []
        self.dfs(root, res)
        first, second = None, None
        for i in range(len(res)-1):
            if res[i].val > res[i+1].val and not first:
                first = res[i]
            if res[i].val > res[i+1].val and first:
                second = res[i+1]
        first.val, second.val = second.val, first.val
        
    def dfs(self, root, res):
        if root:
            self.dfs(root.left, res)
            res.append(root)
            self.dfs(root.right, res)


105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if inorder:
            ind = inorder.index(preorder.pop(0))
            root = TreeNode(inorder[ind])
            root.left = self.buildTree(preorder,inorder[:ind])
            root.right = self.buildTree(preorder,inorder[ind+1:])
            return root

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        return self.build(preorder, 0,len(preorder)-1, inorder, 0, len(inorder)-1)
        
    def build(self, preorder, prestart, preend,
             inorder, instart, inend):
        if prestart>preend:
            return
        root_val = preorder[prestart]
        index = 0
        for i in range(instart,inend+1):
            if root_val == inorder[i]:
                index = i
                break
        left_len = index-instart
        root = TreeNode(root_val)
        root.left = self.build(preorder, prestart+1, prestart+left_len,inorder, instart, index-1)
        root.right = self.build(preorder, prestart+1+left_len, preend, inorder, index+1, inend)
        return root


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        return self.build(inorder, 0, len(inorder)-1, postorder, 0, len(postorder)-1)
    
    def build(self, inorder, instart, inend, postorder, poststart, postend):
        if instart > inend:
            return
        root_val = postorder[postend]
        index = -1
        for i in range(instart, inend+1):
            if inorder[i] == root_val:
                index = i
                break
        left_len = index - instart
        root = TreeNode(root_val)
        root.left = self.build(inorder, instart, index-1, postorder, poststart, poststart+left_len-1)
        root.right = self.build(inorder, index+1, inend, postorder, poststart+left_len, postend-1)
        return root


124. Binary Tree Maximum Path Sum
https://leetcode.com/problems/binary-tree-maximum-path-sum/
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_sum = float('-inf')
        self.dfs(root)
        return self.max_sum
    
    def dfs(self, node):
        if not node: return 0
        
        # only add positive contributions
        leftST_sum = max(0, self.dfs(node.left))
        rightST_sum = max(0, self.dfs(node.right))

        # check if cumulative sum at current node > global max sum so far
        # this evaluates a candidate path
        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)
        
        # add to the current node ONLY one of the children contributions
        # in order to maintain the constraint of considering only paths
        # if not, we would be exploring explore the whole tree - against problem definition
        return max(leftST_sum, rightST_sum) + node.val

226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
class Solution(object):
#T:o(n)
#S:o(n)
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

116. Populating Next Right Pointers in Each Node
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

class Solution(object):
#T:O(n)
#S:O(1)
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if not root:
            return
        self.helper(root.left, root.right)
        return root
    def helper(self, node1, node2):
        if not node1 or not node2:
            return 
        node1.next = node2
        self.helper(node1.left,node1.right)
        self.helper(node2.left,node2.right)
        self.helper(node1.right,node2.left)

114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
class Solution(object):
#T:O(n)
#S:O(1)
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.left)
        self.flatten(root.right)
        left = root.left
        right = root.right
        root.left = None
        root.right = left
        p = root
        while p.right:
            p = p.right
        p.right = right
        return root

654. Maximum Binary Tree
https://leetcode.com/problems/maximum-binary-tree/
class Solution(object):
#T:O(nlogn)
#T:O(n)
    def constructMaximumBinaryTree(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        return self.build(nums,0,len(nums)-1)
        
    def build(self, nums, lo, hi):
        if lo > hi:
            return None
        index = -1
        max_val = float('-inf')
        for i in range(lo, hi+1):
            if nums[i] > max_val:
                index = i
                max_val = nums[i]
        new_root = TreeNode(max_val)
        new_root.left = self.build(nums, lo, index-1)
        new_root.right = self.build(nums, index+1, hi)
        return new_root
